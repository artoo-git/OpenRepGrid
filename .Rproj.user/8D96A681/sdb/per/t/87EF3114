{
    "contents" : "\n###############################################################################\n###  \t\t\t\t\t\t\t        BERTIN DISPLAYS \t\t\t\t                          ###\n###############################################################################\n\n\n\nconstructCellGrob <- function(text, gp=gpar(), horiz=TRUE){\n\tgp <-  modifyList(gpar(fill=grey(.95)), gp)\n\tcol <- gmSelectTextColorByLuminance(gp$fill)\n\tgTree(children=gList( rectGrob(width=1, height=1, \n\t\t\t\t\t\t\t   \t\tgp=gpar(fill=gp$fill, col=\"white\")),\n\t\t\t\t\t  \t  gmSplitTextGrob(text=text, horiz=horiz, gp=modifyList(gp, gpar(col=col)))\n\t\t\t\t\t\t ))\n}\n\n\n\nbertin1 <- function(x, draw=TRUE){\n\tif(!inherits(x, \"repgrid\")) \n\t\tstop(\"Object must be of class 'repgrid'\")\n\t\n  # determine color range (shades of grey)\n  nrow <- nrow(x@ratings)\n  ncol <- ncol(x@ratings)\n  \t\n  # settings\n\theight.element.label <- 5\n\theight.cell <- unit(3, \"mm\")\n\theight.fg.top <- unit(ncol * height.element.label, \"mm\")\n\t\n\n\tbertinCell <- function(label, fill){\n\t\ttextColor <- gmSelectTextColorByLuminance(fill)\n\t\tgTree(children=gList(\n\t\t\t\t\t  rectGrob(width=1, height=1, \n\t\t\t\t\t\t\t   gp=gpar(fill=fill, col=\"white\")),\n\t\t\t\t\t  textGrob(label=label, gp=gpar(lineheight=.7, cex=.6, col=textColor))\n\t\t))\t\t\n\t}\n\t\n\t# rating framegrob\n\tdp.fg <- frameGrob(grid.layout(nrow=nrow, ncol=ncol, respect=F))\n\tscale.range <- x@scale$max - x@scale$min\n\tfor (row in seq_len(nrow)){\n\t\tfor (col in seq_len(ncol)){\n\t\t\tscore <- x@ratings[row, col, 1]\n\t\t\trg <- bertinCell(label=score, fill=grey((score - x@scale$min) / scale.range))\n\t\t\tdp.fg <- placeGrob(dp.fg , rg, row = row, col = col)\n\t\t}\n\t}\n\t\n\t# left framegrob (initial pole)\n\tleft.c.fg <- frameGrob(grid.layout(nrow=nrow, ncol=1))\n\tfor(row in seq_len(nrow)){\n\t  label <- x@constructs[[row]]$leftpole$name\n\t\ttg <- textGrob(label=label, gp=gpar(cex=.6))\n\t\tleft.c.fg <- placeGrob(left.c.fg, tg, row=row)\n\t}\n\t\n\t# top framegrob (elements)\n\ttop.e.fg <- frameGrob(grid.layout(ncol=ncol, nrow=ncol + 1, respect=F))\n\trg <- rectGrob( gp=gpar(fill=\"black\", col=\"white\"), \n\t\t\t\t\t        vp=viewport(width=unit(1, \"points\")))\n\tfor(row in seq_len(ncol)){\n\t  label <- x@elements[[row]]$name\n\t\ttg <- textGrob(label=label, x=.4, just=\"left\", gp=gpar(cex=.6))\n\t\ttop.e.fg <- placeGrob(top.e.fg, tg, row=row, col=row)\t\t\t\t\t\n\t\ttop.e.fg <- placeGrob(top.e.fg, rg, row=row:ncol + 1, col=row)\t\t\t\n\t}\n\t\n\t# combine framegrobs\n\tmain.fg <- frameGrob(grid.layout(nrow=4, ncol=3, heights=c(.1, 2 ,2,.2), widths=c(1,2,1)))\n\tmain.fg <- placeGrob(main.fg, top.e.fg, row= 2, col = 2)\t\n\tmain.fg <- placeGrob(main.fg, left.c.fg, row= 3, col = 1)\n\tmain.fg <- placeGrob(main.fg, dp.fg, row= 3, col = 2)\n\tmain.fg <- placeGrob(main.fg, left.c.fg, row=3, col = 3)\n\tif(draw) grid.draw(main.fg) else main.fg\n}\n\n\n\n\n\nbertin2 <- function(x, ratings=TRUE, top=unit(40, \"mm\"), sides=unit(40, \"mm\") , \n\t\t\t\t\tleft=sides, right=sides, \n\t\t\t\t\tcell=unit(6, \"mm\"), cell.height=cell, cell.width=cell, \n\t\t\t\t\tgp.cells=gpar(), gp.constructs=gpar(), gp.elements=gpar(), \n\t\t\t\t\tbg.col=grey(.95), colors=c(\"white\", \"black\"), draw=TRUE){\n\tif(!inherits(x, \"repgrid\")) \n\t\tstop(\"Object must be of class 'repgrid'\")\n\t\n\tgp.cells <- modifyList(gpar(lineheight=.7, cex=.6, fill=bg.col), gp.cells) \n\tgp.constructs <- modifyList(gpar(lineheight=.7, cex=.8, fill=bg.col), gp.constructs) \n\tgp.elements <- modifyList(gpar(lineheight=.7, cex=.8, fill=bg.col), gp.elements) \n\t\n\t# determine color range (shades of grey)\n\tnrow <- nrow(x@ratings)\n\tncol <- ncol(x@ratings)\n\t\n\theight.top <- top\n\twidth.left <- left\n\twidth.right <- right\n\theight.cell <- cell.height\n\twidth.cell <- cell.width\n\theight.body <- \tnrow * height.cell\n\twidth.body <- ncol * width.cell\n\t\n\tbertinCell <- function(label, fill, gp=gpar(), ratings=TRUE){\n\t\ttextColor <- gmSelectTextColorByLuminance(fill)\n\t\tgp <- modifyList(gp, gpar(col=textColor))\n\t\tif(ratings) tg <- textGrob(label=label, gp=gp) else tg <- nullGrob()\n\t\tgTree(children=gList(\n\t\t\t\t\t  rectGrob(width=1, height=1, \n\t\t\t\t\t\t\t   gp=gpar(fill=fill, col=\"white\")),\n\t\t\t\t\t  tg\n\t\t))\t\t\n\t}\n\t\n\t# rating framegrob\n\tcolorFun <- makeStandardRangeColorRamp(colors)\n\tdp.fg <- frameGrob(grid.layout(nrow=nrow, ncol=ncol, respect=F))\n\tscale.range <- x@scale$max - x@scale$min\n\tscale.min <- x@scale$min\n\tfor (row in seq_len(nrow)){\n\t\tfor (col in seq_len(ncol)){\n\t\t\tscore <- x@ratings[row, col, 1]\n\t\t\trg <- bertinCell(label=score, fill=colorFun((score-scale.min)/scale.range), gp=gp.cells, ratings=ratings)\n\t\t\tdp.fg <- placeGrob(dp.fg , rg, row = row, col = col)\n\t\t}\n\t}\n\t\n\t# left framegrob (initial pole)\n\tleft.c.fg <- frameGrob(grid.layout(nrow=nrow, ncol=1))\n\tfor(row in seq_len(nrow)){\n\t  text <- x@constructs[[row]]$leftpole$name\n\t\ttg <- constructCellGrob(text=text, gp=gp.constructs)\n\t\tleft.c.fg <- placeGrob(left.c.fg, tg, row=row)\t\n\t}\n\t\n\t# right framegrob (contrast pole)\n\tright.c.fg <- frameGrob(grid.layout(nrow=nrow, ncol=1))\n\tfor(row in seq_len(nrow)){\n\t  text <- x@constructs[[row]]$rightpole$name\n\t\ttg <- constructCellGrob(text=text, gp=gp.constructs)\n\t\tright.c.fg <- placeGrob(right.c.fg, tg, row=row)\t\n\t}\n\t\n\t# top framegrob (elements)\n\ttop.e.fg <- frameGrob(grid.layout(ncol=ncol, nrow=1))\n\tfor(col in seq_len(ncol)){\n\t  text <- x@elements[[col]]$name\n\t\ttg <- constructCellGrob(text=text, horiz=FALSE, gp=gp.elements)\n\t\ttop.e.fg <- placeGrob(top.e.fg, tg, row=NULL, col=col)\t\t\t\t\t\n\t}\n\t\n\t# combine framegrobs\n\tmain.fg <- frameGrob(grid.layout(nrow=2, ncol=3, heights=unit.c(height.top, height.body), widths=unit.c(width.left, width.body, width.right)))\n\tmain.fg <- placeGrob(main.fg, top.e.fg, row= 1, col = 2)\t\n\tmain.fg <- placeGrob(main.fg, left.c.fg, row= 2, col = 1)\n\tmain.fg <- placeGrob(main.fg, dp.fg, row= 2, col = 2)\n\tmain.fg <- placeGrob(main.fg, right.c.fg, row=2, col = 3)\n\tif(draw) grid.draw(main.fg) else main.fg\n}\n\n\n\nbertin2PlusLegend <- function(x, ratings=TRUE, top=unit(40, \"mm\"), \n\t\t\t\t\t\t\t\tsides=unit(40, \"mm\"), left=sides, right=sides, \n\t\t\t\t\t\t\t\tcell=unit(6, \"mm\"), cell.height=cell, cell.width=cell, \n\t\t\t\t\t\t\t\tgp.cells=gpar(), gp.constructs=gpar(), gp.elements=gpar(), \n\t\t\t\t\t\t\t\tbg.col=grey(.95), colors=c(\"white\", \"black\"), draw=TRUE,\n\t\t\t\t\t\t\t\tvspace=unit(2,\"mm\"), legend.just=\"left\", legend.height=unit(10, \"mm\"),\n\t\t\t\t\t\t\t\tlegend.width=unit(40, \"mm\"))\n{\n\t\tfg.bertin <- bertin2(\tx=x, ratings=ratings, top=top, \n\t\t\t\t\t\t\t\tsides=sides, left=left, right=right, \n\t\t\t\t\t\t\t\tcell=cell, cell.height=cell.height, cell.width=cell.width, \n\t\t\t\t\t\t\t\tgp.cells=gp.cells, gp.constructs=gp.constructs, gp.elements=gp.elements, \n\t\t\t\t\t\t\t\tbg.col=bg.col, colors=colors, draw=FALSE)\n\t\t\n\t\twidths <- fg.bertin$framevp$layout$widths\n\t\theights <- fg.bertin$framevp$layout$heights\n\t\tnrow <- fg.bertin$framevp$layout$nrow\n\t\tncol <- fg.bertin$framevp$layout$ncol\n\n\t\tcolorFun <- makeStandardRangeColorRamp(colors)\t\n\t\tlg <- gmLegend2(colorFun(c(0,1)), c(\"left pole\", \"right pole\"), ncol=2, byrow=F)\n\t\tfg.legend <- frameGrob(grid.layout(widths=legend.width, just=legend.just))\n\t\tfg.legend <- placeGrob(fg.legend, lg)\n\t\tfg.main <- frameGrob(grid.layout(nrow=nrow + 2, heights=unit.c(heights, vspace, legend.height),\n\t\t\t\t\t\t\t\t\t\t ncol=ncol, widths=widths))\n\t\tfg.main <- placeGrob(fg.main, fg.bertin, row=1:nrow)\n\t\tfg.main <- placeGrob(fg.main, fg.legend , row=nrow + 2)\n\t\t\n\t\tif(draw) grid.draw(fg.main)\telse fg.main\n}\n\n# bertin2PlusLegend(rg2, colors=c(\"darkred\", \"white\"))\n# bertin2PlusLegend(rg2, colors=c(\"darkred\", \"white\"), top=unit(4, \"cm\"), sides=unit(4, \"cm\"))\n\n\n\n\n# TODO: -may work with closures here to store old row and column when marking \n#        rows and columns?\n#       -splitString has a bug, breaks too late\n#       -trimming of elements and constructs\n#\n#' Workhorse for the biplot printing. \n#'\n#' Prints a bertin to the output \n#' device. It uses the R base graphics system and \n#' this is very fast. This is useful for working with grids. Not so much for\n#' producing high-quality output.\n#'\n#' @param x         \\code{repgrid} object. \n#' @param ratings   Vector. rating scores are printed in the cells\n#' @param margins   Vector of length three (default \\code{margins=c(0,1,1)}). \n#'                  1st element denotes the left, 2nd the upper and 3rd the \n#'                  right margin in npc coordinates (i.e. 0 to zero).\n#' @param trim      Vector (default \\code{trim=c(F,F)}).If a number the string\n#'                  is trimmed to the given number of characters. If set \n#'                  to TRUE the labels are trimmed to the available space\n#' @param add       Logical. Wether to add bertin to existent plot (default is \n#'                  \\code{FALSE}). If \\code{TRUE, plot.new()} will not be called\n#'                  \\code{par(new=TRUE)}.\n#' @return \\code{NULL} just for printing.\n#'\n#' @export\n#' @keywords internal\n#' @author Mark Heckmann\n#' \nbertinBase <- function(nrow, ncol, labels=\"\", labels.elements=\"\", \n                       labels.left=\"\", labels.right=\"\", \n                       col.text=NA, cex.text=.6, cex.elements=.7, \n                       cex.constructs=.7, col.fill=grey(.8), border=\"white\", \n                       xlim=c(0,1), ylim=c(0,1), margins=c(0,1,1), lheight=.75,\n                       text.margin=0.005, elements.offset=c(0.002, 0.002), \n                       id=c(T,T), cc=0, cr=0, cc.old=0, cr.old=0, \n                       col.mark.fill=\"#FCF5A4\", print=TRUE, byrow=FALSE, add=FALSE)\n{\n  if (byrow)\n    labels <- as.vector(matrix(labels, nrow=nrow, ncol=ncol, byrow=TRUE))\n  col.fill <- recycle(col.fill, nrow*ncol)    # recycle col.fill if too short e.g. one color\n  if (identical(col.text, NA))                # if not explicitly defined replace col.text according to bg color\n    col.text <- gmSelectTextColorByLuminance(col.fill)\n  else recycle(col.text, nrow*ncol)\n  #if (length(trim) == 1)    # if only one parameter given, extend to the other\n  #   trim <- recycle(trim, 2)\n  if (length(id) == 1)\n    id <- recycle(id, 2)    \n\n  makeMain <- function(){\n    rect(x1, y1, x2, y2, col = col.fill, border = border)\n    text(x1 + cell.width/2, y1 + cell.height/2, labels=labels, col=col.text, cex=cex.text)\n  }\n  \n  makeElements <- function(){       #### elements\n    index <- cascade(ncol, type=2)\n    if (id[2]){\n      labels.elements[index$left] <- paste(labels.elements[index$left], \n                                           \"-\", index$left)\n      labels.elements[index$right] <- paste(index$right, \"-\", \n                                            labels.elements[index$right])\n    }\n\n    height.strokes <- (margins[2] - ylim[2]) / (max(cascade(ncol) + 1))\n    x.lines <- xlim[1] + x1.o * diff(xlim) + cell.width / 2\n    y1.lines <- ylim[2]\n    y2.lines <- y1.lines + cascade(ncol) * height.strokes   # upper end of bertin main plus offset\n    segments(x.lines, y1.lines, x.lines, y2.lines)\n    text(x.lines[index$left] + elements.offset[1], \n        y2.lines[index$left] + elements.offset[2], \n        labels=labels.elements[index$left], adj=c(1,0), cex=cex.elements, xpd=T)\n    text(x.lines[index$right] - elements.offset[1], \n         y2.lines[index$right] + elements.offset[2], \n         labels=labels.elements[index$right], adj=c(0,0), cex=cex.elements, xpd=T)\n  }\n  \n  makeConstructs <- function(){     ### constructs\n    if (id[1]){\n      labels.left <- paste(labels.left, \" (\", 1:nrow, \")\", sep=\"\")\n      labels.right <- paste(\"(\", 1:nrow, \") \", labels.right, sep=\"\")\n    }  \n    labels.left <- baseSplitString(labels.left, availwidth= (xlim[1] - margins[1])* .95, cex=cex.text)\n    labels.right <- baseSplitString(labels.right, availwidth=(margins[3] - xlim[2]) * .95, cex=cex.text)\n    par(lheight=lheight)    # set lineheight\n    text(xlim[1] - text.margin, y1[1:nrow] + cell.height/2, labels=labels.left, \n         cex=cex.constructs, adj=1, xpd=T)\n    text(xlim[2] + text.margin, y1[1:nrow] + cell.height/2, labels=labels.right, \n         cex=cex.constructs, adj=0, xpd=T)\n  }\n  \n  colorRow <- function(cr){\n    par(new=TRUE)   # next plot will overplot not earse the old one, necessary for setting the same regions\n    plot.new()\n    #plot.window(xlim=0:1, ylim=0:1) #, xaxs=\"i\", yaxs=\"i\")#, asp =nrow/ncol)\n    if (cr >= 1 & cr <= nrow){      # color current row cr\n      labels.rows <- labels[(1:ncol-1)*nrow + cr]\n      col.mark.text=gmSelectTextColorByLuminance(col.mark.fill)\n      rect(x1.rc, y1.rc[cr], x2.rc, y2.rc[cr], \n           col = col.mark.fill, border = border)\n      text(x1.rc + cell.width/2, y1.rc[cr] + cell.height/2, \n           labels=labels.rows, col=col.mark.text, cex=cex.text)\n    }\n  }\n  \n  colorColumn <- function(cc){\n    par(new=TRUE)   # next plot will overplot not earse the old one, necessary for setting the same regions\n    plot.new()\n    #plot.window(xlim=0:1, ylim=0:1) #, xaxs=\"i\", yaxs=\"i\")#, asp =nrow/ncol)\n    if (cc >= 1 & cc <= ncol){      # color current column cc\n      labels.cols <- labels[1:nrow + (cc-1)*nrow]\n      #col.fill <- col.fill[1:nrow + (cc-1)*nrow]\n      #col.text=gmSelectTextColorByLuminance(col.fill)\n      col.mark.text=gmSelectTextColorByLuminance(col.mark.fill)\n      rect(x1.rc[cc], y1.rc, x2.rc[cc], y2.rc, \n           col = col.mark.fill, border = border)\n      text(x1.rc[cc] + cell.width/2, y1.rc + cell.height/2, \n           labels=labels.cols, col=col.mark.text, cex=cex.text)  \n      # color vertical stroke\n      height.strokes <- (1 - ylim[2]) / (max(cascade(ncol) + 1))\n      x.lines <- xlim[1] + x1.o * diff(xlim) + cell.width / 2\n      y1.lines <- ylim[2]\n      y2.lines <- y1.lines + cascade(ncol) * height.strokes  \n      segments(x.lines[cc], y1.lines, x.lines[cc], y2.lines[cc], lwd=3, col=\"white\")  # overplot old stroke in white\n      segments(x.lines[cc], y1.lines, x.lines[cc], y2.lines[cc], col=col.mark.fill) \n    }\n  }\n  \n  renewColumn <- function(cc){\n    if (cc >= 1 & cc <= ncol){\n      # vertical stroke\n      height.strokes <- (1 - ylim[2]) / (max(cascade(ncol) + 1))\n      x.lines <- xlim[1] + x1.o * diff(xlim) + cell.width / 2\n      y1.lines <- ylim[2]\n      y2.lines <- y1.lines + cascade(ncol) * height.strokes  \n      segments(x.lines[cc], y1.lines, x.lines[cc], y2.lines[cc], lwd=3, col=\"white\")  # overplot old stroke in white\n      segments(x.lines[cc], y1.lines, x.lines[cc], y2.lines[cc], col=\"black\") \n      \n      # plot rects and text\n      labels.cols <- labels[1:nrow + (cc-1)*nrow]\n      col.fill <- col.fill[1:nrow + (cc-1)*nrow]\n      col.text=gmSelectTextColorByLuminance(col.fill)\n      rect(x1.rc[cc], y1.rc, x2.rc[cc], y2.rc, \n           col = col.fill, border = border)\n      text(x1.rc[cc] + cell.width/2, y1.rc + cell.height/2, \n           labels=labels.cols, col=col.text, cex=cex.text)\n    }\n  }\n  \n  renewRow <- function(cr){\n    if (cr >= 1 & cr <= nrow){\n      # plot rects and text\n      labels.rows <- labels[(1:ncol-1)*nrow + cr]\n      col.fill <- col.fill[(1:ncol-1)*nrow + cr]\n      col.text=gmSelectTextColorByLuminance(col.fill)\n      rect(x1.rc, y1.rc[cr], x2.rc, y2.rc[cr], \n           col = col.fill, border = border)\n      text(x1.rc + cell.width/2, y1.rc[cr] + cell.height/2, \n           labels=labels.rows, col=col.text, cex=cex.text)\n    }\n  }\n  \n  # make basic calculations\n  x1.o <- 0:(ncol - 1)/ncol\n  x2.o <- 1:ncol/ncol\n  y1.o <- rev(0:(nrow - 1)/nrow)\n  y2.o <- rev(1:nrow/nrow)\n  \n  x1 <- rep(x1.o, each=nrow)\n  x2 <- rep(x2.o, each=nrow)\n  y1 <- rep(y1.o, ncol)\n  y2 <- rep(y2.o, ncol)\n\n  x1 <- xlim[1] + x1 * diff(xlim)      # rescale coordinates according to given limits\n  x2 <- xlim[1] + x2 * diff(xlim) \n  y1 <- ylim[1] + y1 * diff(ylim)\n  y2 <- ylim[1] + y2 * diff(ylim)\n  \n  cell.width <- diff(xlim) / ncol\n  cell.height <- diff(ylim) / nrow\n  \n  x1.rc <- x1[(1:ncol)*nrow]      # calc coords for row and col starts and ends\n  x2.rc <- x2[(1:ncol)*nrow]\n  y1.rc <- y1[1:nrow]\n  y2.rc <- y2[(1:nrow)]\n  \n  # set plotting parameters\n  #old.par <- par(no.readonly = TRUE)    # save parameters\n  #on.exit(par(old.par))                 # reset old par when done\n  op <- par(oma=rep(0,4), mar=rep(0,4), xaxs=\"i\", yaxs=\"i\")\n  if (print)                  # in case no new printing should occur\n    par(new=FALSE)\n  else \n    par(new=TRUE)\n  if (add)                    # will bertin be added to existent plot?\n    par(new=TRUE)\n  \n  plot.new()\n  #plot.window(xlim=0:1, ylim=0:1) #, xaxs=\"i\", yaxs=\"i\")#, asp =nrow/ncol)\n  \n  # plotting\n  if (print) {\n    makeMain()\n    makeElements()\n    makeConstructs()\n    colorRow(cr)        # color current row or column\n    colorColumn(cc)\n  } else {\n    renewColumn(cc.old)\n    renewRow(cr.old)\n    colorRow(cr)\n    colorColumn(cc)\n  }     \n  #par(op)\n  invisible(NULL)\n}\n\n\n#bertinBase(20, 70, xlim=c(.2,.8), ylim=c(0,.4))\n#bertinBase(10,20)\n#bertinBase(10,20, xlim=c(0.1, .9), ylim=c(.2, .8), cex.text=.8)\n#bertinBase(20, 30, grey(runif(13)), cex.text=.6)\n#labels <- randomSentences(20, 6)\n#bertinBase(20, 70, xlim=c(.25,.75), ylim=c(.1,.4), margins=c(.03,.9,.97), id=F, \n#           labels.l=labels, labels.ri=labels, labels.el=rep(labels, 4))\n           \n#x <- randomGrid(20, 40)\n#nc <- length(x@constructs)\n#ne <- length(x@elements)\n#color <- c(\"darkred\", \"white\", \"darkgreen\")\n#colorFun <- makeStandardRangeColorRamp(color)\n#scale.min <- x@scale$min\n#scale.max <- x@scale$max\n#scores <- as.vector(x@ratings[,,1])\n#col.fill <- colorFun((scores-scale.min)/(scale.max-scale.min))\n#bertinBase(nc, ne, col.fill, scores , xlim=c(.2, .8), ylim=c(0,.6), cex.text=.6, border=\"white\")\n#bertinBase(nc, ne, col.fill, scores , xlim=c(.2, .8), ylim=c(0,.6), cex.text=.6, border=\"white\", cc=10, cr=10, pri=F)\n#bertinBase(nc, ne, col.fill, scores , xlim=c(.2, .8), ylim=c(0,.6), cex.text=.6, border=\"white\", cc.old=10, pri=F)\n#bertinBase(nc, ne, col.fill, scores , xlim=c(.2, .8), ylim=c(0,.6), cex.text=.6, border=\"white\", cr.old=10, pri=F)\n\n#bertinBase(nc, ne, col.fill, scores , xlim=c(.2, .8), ylim=c(0,.6), cex.text=.6, border=\"white\")\n#for (row in 1:10){\n#  for (col in 1:15) {\n#    bertinBase(nc, ne, col.fill, scores , xlim=c(.2, .8), ylim=c(0,.6), cex.text=.6, \n#               border=\"white\", cc=col, cr=row, cc.old=col -1, cr.old=row-1, pri=F)\n#    Sys.sleep(.2)\n#  }\n#}\n\n\n#' Make Bertin display of grid data.\n#'\n#' One of the most popular ways of displaying grid data has been adopted \n#' from Bertin's (1974) graphical proposals, which have had an immense \n#' influence onto data visualization. One of the most appealing \n#' ideas presented by Bertin is the concept of the reordable matrix. \n#' It is comprised of graphical displays for each cell, allowing to \n#' identify structures by eye-balling reordered versions of the data matrix \n#' (see Bertin, 1974). In the context of repertory grids, \n#' the display is made up of a simple colored rectangle where the color \n#' denotes the corresponding score. Bright values correspond to low, dark \n#' to high scores. For an example of how to analyze a Bertin display see \n#' e.g. Dick (2000) and Raeithel (1998).\n#'\n#' @param x               \\code{repgrid} object.\n#' @param colors          Vector. Two or more colors defininig the color ramp for \n#'                        the bertin (default \\code{c(\"white\", \"black\")}).\n#' @param showvalues      Logical. Wether scores are shown in bertin\n#' @param xlim            Vector. Left and right limits inner bertin (default \n#'                        \\code{c(.2, .8)}).\n#' @param ylim            Vector. Lower and upper limits of inner bertin\n#'                        default(\\code{c(.0, .6)}).\n#' @param margins         Vector of length three (default \\code{margins=c(0,1,1)}). \n#'                        1st element denotes the left, 2nd the upper and 3rd the \n#'                        right margin in npc coordinates (i.e. 0 to zero).\n#' @param cex.elements    Numeric. Text size of element labels (default \\code{.7}).\n#' @param cex.constructs  Numeric. Text size of construct labels (default \\code{.7}).\n#' @param cex.text        Numeric. Text size of scores in bertin cells (default \\code{.7}).\n#' @param col.text        Color of scores in bertin (default \\code{NA}). By default\n#'                        the color of the text is chosen according to the \n#'                        background color. If the background ist bright the text \n#'                        will be black and vice versa. When a color is specified\n#'                        the color is set independetn of background.\n#' @param border          Border color of the bertin cells (default \\code{white}).\n#' @param lheight         Line height for constructs.\n#' @param id              Logical. Wheteher to print id number for constructs and elements\n#'                        respectively (default \\code{c(T,T)}).\n#' @param cc              Numeric. Current column to mark.\n#' @param cr              Numeric. Current row to mark.\n#' @param cc.old          Numeric. Column to unmark.\n#' @param cr.old          Numeric. Row to unmark.\n#' @param col.mark.fill   Color of marked row or column (default \\code{\"#FCF5A4\"}).\n#' @param print           Print whole bertin. If \\code{FALSE} only current and old\n#'                        row and column are printed.\n#' @param ...             Optional arguments to be passed on to \\code{bertinBase}.\n#'\n#' @return \\code{NULL} just for the side effects, i.e. printing.\n#'\n#' @export\n#' @references    Bertin, J. (1974). \\emph{Graphische Semiologie: Diagramme, Netze, \n#'                  Karten}. Berlin, New York: de Gruyter.\n#'\n#'                Dick, M. (2000). The Use of Narrative Grid Interviews in \n#'                  Psychological Mobility Research. \\emph{Forum Qualitative \n#'                  Sozialforschung / Forum: Qualitative Social Research, 1}(2). \n#'                \n#'                Raeithel, A. (1998). Kooperative Modellproduktion von \n#'                  Professionellen und Klienten - erlauetert am Beispiel des \n#'                  Repertory Grid. \\emph{Selbstorganisation, Kooperation, Zeichenprozess: \n#'                  Arbeiten zu einer kulturwissenschaftlichen, anwendungsbezogenen \n#'                  Psychologie} (pp. 209-254). Opladen: Westdeutscher Verlag.\n#'\n#' @examples \\dontrun{\n#' \n#'    bertin(feixas2004)\n#'    bertin(feixas2004, c(\"white\", \"darkblue\"))\n#'    bertin(feixas2004, showvalues=F)\n#'    bertin(feixas2004, border=\"grey\")\n#'    bertin(feixas2004, cex.text=.9)\n#'    bertin(feixas2004, id=c(F, F))\n#'    \n#'    bertin(feixas2004, cc=3, cr=4)\n#'    bertin(feixas2004, cc=3, cr=4, col.mark.fill=\"#e6e6e6\")\n#' }\n#'                       \nbertin <- function(x, colors=c(\"white\", \"black\"), showvalues=TRUE, \n                   xlim=c(.2, .8), ylim=c(0,.6), margins=c(0,1,1),\n                   cex.elements=.7, cex.constructs=.7, cex.text=.6, col.text=NA, \n                   border=\"white\", lheight=.75, id=c(T,T),\n                   cc=0, cr=0, cc.old=0, cr.old=0, col.mark.fill=\"#FCF5A4\", print=TRUE, \n                   ...){\n  if (!inherits(x, \"repgrid\")) \t\t\t\t\t\t\t      # check if x is repgrid object\n  \tstop(\"Object x must be of class 'repgrid'\")\n  \t\n  nc <- length(x@constructs)\n  ne <- length(x@elements)\n  colorFun <- makeStandardRangeColorRamp(colors)\n  scale.min <- x@scale$min\n  scale.max <- x@scale$max\n  scores <- as.vector(x@ratings[,,1])\n  scores.standardized <- (scores-scale.min)/(scale.max-scale.min) \n  col.fill <- colorFun(scores.standardized)\n  if (!showvalues)\n    scores <- recycle(\"\", nc * ne)\n  bertinBase(nrow=nc, ncol=ne, labels=scores, labels.elements=getElementNames(x),\n             labels.left=getConstructNames(x)$leftpole, \n             labels.right=getConstructNames(x)$rightpole,\n             col.fill=col.fill,\n             xlim=xlim, ylim=ylim, margins=margins,\n             cex.elements=cex.elements, cex.constructs=cex.elements,\n             cex.text=cex.text, col.text=col.text, \n             border=border, lheight=lheight, id=id, cc=cc, cr=cr, cc.old=cc.old, cr.old=cr.old,\n             col.mark.fill=col.mark.fill, print=print, ...)\n  invisible(NULL)\n}\n\n#x <- randomGrid(10,20)\n#x\n\n\n\n\n\n#' Bertin display with corresponding cluster anaylsis. \n#'\n#' Element columns and \n#' constructs rows are ordered according to cluster criterion. Various \n#' distance measures as well as cluster methods are supported.\n#'\n#' @param x           \\code{repgrid} object.\n#' @param  dmethod    The distance measure to be used. This must be one of \n#'                    \\code{\"euclidean\"}, \\code{\"maximum\"}, \\code{\"manhattan\"}, \n#'                    \\code{\"canberra\"}, \\code{\"binary\"}, or \\code{\"minkowski\"}.\n#'                    Default is \\code{\"euclidean\"}.\n#'                    Any unambiguous substring can be given (e.g. \\code{\"euc\"} \n#'                    for \\code{\"euclidean\"}). \n#'                    A vector of length two can be passed if a different distance measure for\n#'                    constructs and elements is wanted (e.g.\\code{c(\"euclidean\", \"manhattan\")}).\n#'                    This will apply euclidean distance to the constructs and\n#'                    manhattan distance to the elements.\n#'                    For additional information on the different types see\n#'                    \\code{?dist}. \n#' @param  cmethod    The agglomeration method to be used. This should be (an\n#'                    unambiguous abbreviation of) one of \\code{\"ward\"}, \n#'                    \\code{\"single\"}, \\code{\"complete\"}, \\code{\"average\"}, \n#'                    \\code{\"mcquitty\"}, \\code{\"median\"} or \\code{\"centroid\"}.\n#'                    Default is \\code{\"ward\"}.\n#'                    A vector of length two can be passed if a different cluster method for\n#'                    constructs and elements is wanted (e.g.\\code{c(\"ward\", \"euclidean\")}).\n#'                    This will apply ward clustering to the constructs and\n#'                    single linkage clustering to the elements. If only one of either\n#'                    constructs or elements is to be clustered the value \\code{NA}\n#'                    can be supplied. E.g. to cluster elements only use \\code{c(NA, \"ward\")}.\n#' @param  p          The power of the Minkowski distance, in case \\code{\"minkowski\"}\n#'                    is used as argument for \\code{dmethod}. \\code{p} can be a vector\n#'                    of length two if different powers are wanted for constructs and\n#'                    elements respectively (e.g. \\code{c(2,1)}).\n#' @param align       Whether the constructs should be aligned before clustering\n#'                    (default is \\code{TRUE}). If not, the grid matrix is clustered \n#'                    as is. See Details section in function \\code{\\link{cluster}} for more information.\n#' @param trim        The number of characters a construct is trimmed to (default is\n#'                    \\code{10}). If \\code{NA} no trimming is done. Trimming\n#'                    simply saves space when displaying the output.\n#' @param type        Type of dendrogram. Either or \\code{\"triangle\"} (default) \n#'                    or \\code{\"rectangle\"} form.\n#' @param xsegs       Numeric vector of normal device coordinates (ndc i.e. 0 to 1) to mark\n#'                    the widths of the regions for the left labels, for the\n#'                    bertin display, for the right labels and for the \n#'                    vertical dendrogram (i.e. for the constructs).\n#' @param ysegs       Numeric vector of normal device coordinates (ndc i.e. 0 to 1) to mark\n#'                    the heights of the regions for the horizontal dendrogram \n#'                    (i.e. for the elements), for the bertin display and for \n#'                    the element names.\n#' @param x.off       Horizontal offset between construct labels and construct dendrogram and \n#                     between the outer right margin and the dendrogram \n#'                    (default is \\code{0.01} in normal device coordinates).\n#' @param y.off       Vertical offset between bertin display and element dendrogram and \n#                     between the lower margin and the dendrogram\n#'                    (default is \\code{0.01} in normal device coordinates).\n#' @param cex.axis    \\code{cex} for axis labels, default is \\code{.6}.\n#' @param col.axis    Color for axis and axis labels, default is \\code{grey(.4)}.\n#' @param draw.axis   Whether to draw axis showing the distance metric for the dendrograms \n#'                    (default is \\code{TRUE}).\n#' @param ...         additional parameters to be passed to function \\code{\\link{bertin}}.\n#'\n#' @return            A list of two \\code{\\link{hclust}} object, for elements and constructs\n#'                    respectively.\n#'\n#' @author        Mark Heckmann\n#' @export\n#' @seealso  \\code{\\link{cluster}}\n#'\n#' @examples \\dontrun{\n#'\n#'    # default is euclidean distance and ward clustering \n#'    bertinCluster(bell2010)                                     \n#'\n#'    ### applying different distance measures and cluster methods\n#'\n#'    # euclidean distance and single linkage clustering \n#'    bertinCluster(bell2010, cmethod=\"single\")\n#'    # manhattan distance and single linkage clustering             \n#'    bertinCluster(bell2010, dmethod=\"manhattan\", cm=\"single\") \n#'    # minkowksi distance with power of 2 = euclidean distance  \n#'    bertinCluster(bell2010, dm=\"mink\", p=2)                     \n#' \n#'    ### using different methods for constructs and elements\n#'\n#'    # ward clustering for constructs, single linkage for elements\n#'    bertinCluster(bell2010, cmethod=c(\"ward\", \"single\"))        \n#'    # euclidean distance measure for constructs, manhatten \n#'    # distance for elements\n#'    bertinCluster(bell2010, dmethod=c(\"euclidean\", \"man\"))\n#'    # minkowski metric with different powers for constructs and elements    \n#'    bertinCluster(bell2010, dmethod=\"mink\", p=c(2,1)))          \n#'\n#'    ### clustering either constructs or elements only\n#'    # euclidean distance and ward clustering for constructs no \n#'    # clustering for elements\n#'    bertinCluster(bell2010, cmethod=c(\"ward\", NA))  \n#'    # euclidean distance and single linkage clustering for elements \n#'    # no clustering for constructs            \n#'    bertinCluster(bell2010, cm=c(NA, \"single\"))                 \n#'\n#'    ### changing the appearance\n#'    # different dendrogram type        \n#'    bertinCluster(bell2010, type=\"rectangle\")  \n#'    # no axis drawn for dendrogram                 \n#'    bertinCluster(bell2010, draw.axis=F)                        \n#'\n#'    ### passing on arguments to bertin function via ...\n#'     # grey cell borders in bertin display\n#'    bertinCluster(bell2010, border=\"grey\")  \n#'    # omit printing of grid scores, i.e. colors only                  \n#'    bertinCluster(bell2010, showvalues=FALSE)                   \n#'\n#'    ### changing the layout\n#'    # making the vertical dendrogram bigger\n#'    bertinCluster(bell2010, xsegs=c(0, .2, .5, .7, 1))\n#'    # making the horizontal dendrogram bigger          \n#'    bertinCluster(bell2010, ysegs=c(0, .3, .8, 1))              \n#' }\n#'\nbertinCluster <- function(x, dmethod=c(\"euclidean\", \"euclidean\"), \n                          cmethod=c(\"ward\", \"ward\"), p=c(2,2), align=TRUE, \n                          trim=NA, type=c(\"triangle\"), \n                          xsegs = c(0, .2, .7, .9, 1), ysegs = c(0, .1, .7, 1),\n                          x.off=0.01, y.off=0.01,\n                          cex.axis =.6, col.axis =  grey(.4), draw.axis=TRUE, ...)\n{\n  if (length(dmethod) == 1)       # if only one value is passed\n    dmethod <- rep(dmethod, 2)\n  if (length(cmethod) == 1)       # if only one value is passed\n    cmethod <- rep(cmethod, 2)\n  if (length(p) == 1)             # if only one value is passed\n    p <- rep(p, 2)\n\n  cex.dend <- 0.001       # size text dendrogram, only needed for sanity \n                          # check purposes, otherwise 0.001 so no dend labels are drawn\n                                                \n  inr.x <- xsegs[4]       # inner figure region (bertin) ndc x coordinate range\n                          # range goes from left side to y dendrogram region                                            \n  inr.y <- 1 - ysegs[2]   # bertin fig region range as ndc coords\n                          # range goes from end of x dendrogram region to end of device (i.e. 1)              \n  \n  # transform xsegs and ysegs coordinates (ndc) into \n  # ndc coordinates for inner figure region used by bertin plot\n  xlim.bertin <- xsegs[2:3] / inr.x\n  ylim.bertin <- c(0, (ysegs[3] - ysegs[2]) / inr.y)\n  \n  if (align)               # align grid if promoted, uses dmethod etc. for constructs, i.e. [1]\n    x <- align(x, along = along, dmethod = dmethod[1], \n               cmethod = cmethod[1], p = p[1])  \n    \n  r <- getRatingLayer(x, trim=trim)    # get ratings\n\n  # dendrogram for constructs\n  if (is.na(cmethod[1])){\n    con.ord <- seq_len(getNoOfConstructs(x))          # no change in order\n    fit.constructs <- NULL\n  } else {\n    dc <- dist(r, method = dmethod[1], p=p[1])        # make distance matrix for constructs\n    fit.constructs <- hclust(dc, method=cmethod[1])   # hclust object for constructs\n    dend.con <- as.dendrogram(fit.constructs)\n    con.ord <- order.dendrogram(rev(dend.con))\n  }\n  \n  # dendrogram for elements\n  if (is.na(cmethod[2])){\n    el.ord <- seq_len(getNoOfConstructs(x))          # no change in order\n    fit.elements <- NULL\n  } else {\n    de <- dist(t(r), method = dmethod[2], p=p[2])     # make distance matrix for elements\n    fit.elements <- hclust(de, method=cmethod[2])     # hclust object for elements\n    dend.el <- as.dendrogram(fit.elements)\n    el.ord <- order.dendrogram(dend.el)\n  }\n  \n  x <- x[con.ord, el.ord]   # reorder repgrid object\n  \n  plot.new()\n  par(fig = c(xsegs[c(1,4)], ysegs[c(2,4)]) , new=T)\n  #par(fig = c(0, .8, .2, 1), new=T)\n  \n  bertin(x, xlim=xlim.bertin, ylim=ylim.bertin, add=T, ...)           # print reordered bertin\n  \n  # x dendrogram (horizontal) elements\n  if (!is.na(cmethod[2])){\n    dend.x.fig <- c(xsegs[2:3], ysegs[1:2]) + c(0,0, y.off, -y.off)     # adjust for offsets\n    par(fig = dend.x.fig, new=T, mar=c(0,0,0,0))\n    ymax.el <- attr(dend.el, \"height\")\n    plot(dend.el, horiz=F, xlab=\"\", xaxs=\"i\", yaxs=\"i\", yaxt=\"n\",\n          nodePar=list(cex=0, lab.cex=cex.dend), ylim=c(ymax.el,0), type=type)\n    if (draw.axis)              # wether to draw axis\n      axis(2, las=1, cex.axis=cex.axis, col=col.axis, col.axis=col.axis)\n  }\n  \n  # y dendrogram (vertical) constructs\n  if (!is.na(cmethod[1])){\n    dend.y.fig <- c(xsegs[4:5], ysegs[2:3]) + c(x.off, -x.off, 0, 0)    # adjust for offsets           \n    par(fig = dend.y.fig, new=T, mar=c(0,0,0,0))\n    xmax.con <- attr(dend.con, \"height\")\n    plot(dend.con, horiz=T, xlab=\"\", xaxs=\"i\", yaxs=\"i\", yaxt=\"n\",\n          nodePar=list(cex=0, lab.cex=cex.dend), xlim=c(0,xmax.con), type=type)\n    if (draw.axis)              # wether to draw axis\n      axis(1, las=1, cex.axis=cex.axis, col=col.axis, col.axis= col.axis)\n  }\n  # return hclust objects for elements and constructs\n  invisible(list(constructs=fit.constructs, elements=fit.elements))\n}\n\n# TODO: use of layout does not work with bertinCluster\n# a future version could use layout\n# layout (matrix(1:4), 2)\n# bertinCluster(bell2010)\n\n# bertinCluster(bell2010, type=\"t\", bor=grey(.5))\n# dev.new()\n# bertinCluster(bell2010, type=\"t\", dm=\"manhattan\", cm=\"single\")\n# dev.new()\n# bertinCluster(bell2010, type=\"t\", dm=\"manhattan\", cm=\"centroid\")\n\n\n\n# base graphics for quick clustering\n# # make dendrogram\n#x <- bell2010\n\n# compute new layout of bertin\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1380197488627.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4259787454",
    "id" : "87EF3114",
    "lastKnownWriteTime" : 1380199117,
    "path" : "~/_mh/programming/R/pkg_dev/grid/OpenRepGrid/OpenRepGrid/R/bertin.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}