{
    "contents" : "###############################################################################\n###  \t\t\t\t\t\t            GRID INDEX MEASURES     \t\t\t\t\t\t\t          ###\n###                                                                         ###\n###     All function for index measures start with a lower case \"i\"         ###\n###     e.g. 'iBias' that stand for index followed by the an acronym        ###\n###     of what is calculated.                                              ###\n###                                                                         ###\n###############################################################################\n\n\n###############################################################################\n###  \t\t\t\t\t\t            MEASURES FROM SLATER 1977\t\t\t\t\t\t\t          ###\n###############################################################################\n\n#' Calculate 'bias' of grid as defined by Slater (1977). \n#'\n#' \"Bias records a tendency for reponses to accumulate at one end of the \n#' grading scale\" (Slater, 1977, p.88). \n#'\n#' @param  x        \\code{repgrid} object.\n#' @param min       Minimum grid scale value. \n#' @param max       Maximum grid scale value.\n#' @param digits    Numeric. Number of digits to round to (default is \n#'                  \\code{2}).\n#' @return Numeric.\n#'\n#' @references      Slater, P. (1977). \\emph{The measurement of intrapersonal space \n#'                  by Grid technique}. London: Wiley.\n#'\n#' @note STATUS:    Working and checked against example in Slater, 1977, p. 87.\n#'                  \n#' @author        Mark Heckmann\n#' @export\n#' @seealso       \\code{\\link{indexVariability}} \n#'\nindexBias <- function(x, min, max, digits=2){\n  dat <- x@ratings[ , ,1]\n\tif (missing(min)) \n\t  min <- x@scale$min\n\tif (missing(max)) \n    max <- x@scale$max\n\tp <- min + (max - min)/2 \t\t\t# scale midpoint\n\tq <- max - p\t\t\t\t\t\t\t\t\t# distance to scale limits\n\tn <- nrow(dat)\t\t\t\t\t\t\t\t# number of rows (constructs)\n\trow.means <- apply(dat, 1, mean, na.rm=TRUE)\t\t# means of construct rows\n\tbias <- (sum((row.means - p)^2) / n)^.5 / q\t\t  # calculation of bias\n\tround(bias, digits)\n}\n\n\n#' Calculate 'variability' of a grid as defined by Slater (1977).\n#'\n#' Variability records a tendency for the responses to gravitate \n#' towards both end of the gradings scale. (Slater, 1977, p.88).\n#'\n#' @param  x      \\code{repgrid} object.\n#' @param min     Minimum grid scale value. \n#' @param max     Maximum grdi scale value. \n#' @param digits  Numeric. Number of digits to round to (default is \n#'                \\code{2}).\n#' @return        Numeric.\n#'\n#' @references    Slater, P. (1977). \\emph{The measurement of intrapersonal space \n#'                by Grid technique}. London: Wiley.\n#'\n#' @note          STATUS: working and checked against example in Slater, 1977 , p.88.\n#'\n#' @author        Mark Heckmann\n#' @export\n#' @seealso       \\code{\\link{indexBias}} \n#'\nindexVariability <- function(x, min, max, digits=2){\n  if (missing(min)) \n\t  min <- x@scale$min\n\tif (missing(max)) \n    max <- x@scale$max\n    \n  D <- as.matrix(center(x))       # row centered grid matrix\n  W <- D %*% t(D)\t\t\t\t\t\t\t\t\t# co-variation Matrix W\n  V <- diag(W)\t\t\t\t\t\t\t\t\t\t# extract trace (construct variations)\n  V.tot <- sum(V, na.rm=T)       # total variation\n  \n  p <- min + (max - min)/2 \t\t\t\t\t    # scale midpoint\n\tq <- max - p\t\t\t\t\t\t\t\t          # distance to scale limits\n\tn <- nrow(D)\t\t\t\t\t\t\t\t        # number of rows (constructs)\n\tm <- ncol(D)\t\t\t\t\t\t\t\t        # number of columns (elements)\n\tres <- (V.tot/(n*(m-1)))^.5/q\t\t\t        # calculate variability\n\tround(res, digits)\n}\n\n\n###############################################################################\n###  \t\t\t\t\t\t              OTHER INDICES          \t\t\t\t\t\t\t          ###\n###############################################################################\n\n#' Percentage of Variance Accounted for by the First Factor (PVAFF)\n#'\n#' The PVAFF is used as \n#' a measure of cognitive complexity. It was introduced in an unpublished\n#' PhD thesis by Jones (1954, cit. Bonarius, 1965).\n#' To calculate it, the 'first factor' is extracted from the construct \n#' correlation matrix by principal component analysis.\n#' The PVAFF reflects the amount of variation that is accounted for by a single \n#' linear component. If a single latent component is able to explain the\n#' variation in the grid, the cognitive complexity is said to be low. \n#' In this case the construct system is regarded as 'simple' (Bell, 2003).\n#'\n#' The percentage of variance is calculated using the corelation matrix\n#' of te constructs submitted to \\code{\\link{svd}}.\n#' \n#' @section Development: \n#' TODO: Results have not yet been checked against other grid programs.\n#'\n#' @param x         \\code{repgrid} object.\n#' @export\n#' @author          Mark Heckmann\n#' @references      Bell, R. C. (2003). An evaluation of indices used to \n#'                  represent construct structure. In G. Chiari & M. L. \n#'                  Nuzzo (Eds.), \\emph{Psychological Constructivism and \n#'                  the Social World} (pp. 297-305). Milan: FrancoAngeli.\n#'\n#'                  Bonarius, J. C. J. (1965). Research in the personal \n#'                  construct theory of George A. Kelly: role construct \n#'                  repertory test and basic theory. In B. A. Maher (Ed.), \n#'                  \\emph{Progress in experimental personality research}\n#'                  (Vol. 2). New York: Academic Press.\n#'\n#'                  James, R. E. (1954). \\emph{Identification in terms of personal \n#'                  constructs} (Unpublished doctoral thesis). Ohio State \n#'                  University, Columbus, OH.  \n#'\n#' @examples \n#'\n#'    indexPvaff(bell2010)\n#'    indexPvaff(feixas2004)\n#'\n#'    # save results to object\n#'    p <- indexPvaff(bell2010)\n#'    p\n#'\n#'\nindexPvaff <- function(x){\n\tif (!inherits(x, \"repgrid\")) \n\t\tstop(\"Object must be of class 'repgrid'\")\n  cr <- constructCor(x)\n  sv <- svd(cr)$d \n  pvaff <- sv[1]^2/sum(sv^2)\n  return(pvaff)\n}\n\n\n#' Print method for class indexPvaff.\n#' \n#' @param x         Object of class indexPvaff.\n#' @param digits    Numeric. Number of digits to round to (default is \n#'                  \\code{2}).\n#' @param ...       Not evaluated.\n#' @export\n#' @method          print indexPvaff\n#' @keywords        internal\n#'\nprint.indexPvaff <- function(x, digits=2, ...)\n{\n  cat(\"\\n########################################################\")\n  cat(\"\\nPercentage of Variance Accounted for by the First Factor\")\n  cat(\"\\n########################################################\")\n  cat(\"\\n\\nPVAFF: \", round(x*100, digits), \"%\")\n}\n\n\n# Another version of PVAFF giving slightly different results\n# maybe due to Bessel's correction. Still unclear which one \n# is correct.\nindexPvaff2 <- function(x){\n\tif (!inherits(x, \"repgrid\")) \n\t\tstop(\"Object must be of class 'repgrid'\")\n\tr <- constructCor(x)\n  sv <- princomp(r)$sdev\n  pvaff <- sv[1]^2/sum(sv^2)\n}\n\n\n#' Calculate intensity index.\n#'\n#' The Intensity index has been suggested by Bannister (1960) as a \n#' measure of the amount of construct linkage. Bannister suggested \n#' that the score reflects the degree of organization of the construct \n#' system under investigation (Bannister & Mair, 1968). The index \n#' resulted from his and his colleagues work on construction systems \n#' of patient suffering schizophrenic thought disorder. The concept of \n#' intensity has a theoretical connection to the notion of \"tight\" and \n#' \"loose\" construing as proposed by Kelly (1991). While tight constructs \n#' lead to unvarying prediction, loose constructs allow for varying \n#' predictions. Bannister hypothesized that schizophrenic thought disorder \n#' is liked to a process of extremely loose construing leading to a loss \n#' of predictive power of the subject's construct system. The Intensity \n#' score as a structural measure is thought to reflect this type of \n#' system disintegration (Bannister, 1960). \n#' \n#' Implementation as in the Gridcor programme and explained on the \n#' correspoding help pages: \n#' \"\\ldots the sum of the squared values of the correlations \n#' of each construct with the rest of the constructs, averaged by the total \n#' number of constructs minus one. This process is repeated with each \n#' element, and the overall Intensity is calculated by averaging the \n#' intensity scores of constructs and elements.\"\n#' \\url{http://www.terapiacognitiva.net/record/pag/man11.htm}.\n#' Currently the total is calculated as the unweighted average of all \n#' single scores (for elements and construct).\n#'\n#' @title         Intensity index \n#'\n#' @section Development: TODO: Results have not been tested against other programs' results.\n#'\n#' @param x       \\code{repgrid} object.\n#' @param rc      Whether to use Cohen's rc for the calculation of\n#'                inter-element correlations. See \\code{\\link{elementCor}}\n#'                for further explanations of this measure.\n#' @param trim    The number of characters a construct is trimmed to (default is\n#'                \\code{30}). If \\code{NA} no trimming occurs. Trimming\n#'                simply saves space when displaying correlation of constructs\n#'                or elements with long names.\n#' @return        An object of class \\code{indexIntensity} containing a list \n#'                with the following elements: \\cr\n#'                \n#'  \\item{c.int}{Intensity scores by construct.}\n#'  \\item{e.int}{Intensity scores by element.}\n#'  \\item{c.int.mean}{Average intensity score for constructs.}\n#'  \\item{e.int.mean}{Average intensity score for elements.}\n#'  \\item{total.int}{Total intensity score.}\n#'\n#' @export      \n#' @author      Mark Heckmann\n#'\n#' @references    Bannister, D. (1960). Conceptual structure in \n#'                thought-disordered schizophrenics. \\emph{The Journal \n#'                of mental science}, 106, 1230-49.\n#' @examples \n#' \n#'  indexIntensity(bell2010)\n#'  indexIntensity(bell2010, trim=NA)\n#'\n#'  # using Cohen's rc for element correlations\n#'  indexIntensity(bell2010, rc=TRUE)\n#'\n#'  # save output \n#'  x <- indexIntensity(bell2010)\n#'  x\n#'  \n#'  # printing options\n#'  print(x, digits=4)\n#'  \n#'  # accessing the objects' content\n#'  x$c.int\n#'  x$e.int\n#'  x$c.int.mean\n#'  x$e.int.mean\n#'  x$total.int\n#' \nindexIntensity <- function(x, rc=FALSE, trim=30)\n{\n  if (!inherits(x, \"repgrid\")) \n\t\tstop(\"Object must be of class 'repgrid'\")\n\tcr <- constructCor(x, trim=trim)\n\tnc <- getNoOfConstructs(x)\n\tdiag(cr) <- 0                                           # out zeros in diagonal (won't have an effect)\n  c.int <- apply(cr^2, 2, function(x) sum(x) / (nc-1))    # sum of squared correlations / nc -1 \n\t\n\ter <- elementCor(x, rc=rc, trim=trim) \n\tne <- getNoOfElements(x)\n\tdiag(er) <- 0                                           # out zeros in diagonal (won't have an effect)\n  e.int <- apply(er^2, 2, function(x) sum(x) / (ne-1))    # sum of squared correlations / ne -1 \n  \t\n\tc.int.mean <- mean(c.int, na.rm=TRUE)       # mean of construct intensity scors\n\te.int.mean <- mean(e.int, na.rm=TRUE)       # mean of element intensity scors\n\t\n\ttotal.int <- mean(c(c.int, e.int, na.rm=TRUE))\n\t\n\tres <- list(c.int=c.int,\n\t            e.int=e.int,\n\t            c.int.mean=c.int.mean,\n\t            e.int.mean=e.int.mean,\n\t            total.int=total.int)\t            \n\tclass(res) <- \"indexIntensity\"\n  res\n}\n\n\n#' Print method for class indexIntensity.\n#' \n#' @param x         Object of class indexIntensity.\n#' @param digits    Numeric. Number of digits to round to (default is \n#'                  \\code{2}).\n#' @param ...       Not evaluated.\n#' @export\n#' @method          print indexIntensity\n#' @keywords        internal\n#'\nprint.indexIntensity <- function(x, digits=2, ...)\n{\n  cat(\"\\n################\")\n  cat(\"\\nIntensity index\")\n  cat(\"\\n################\")\n  cat(\"\\n\\nTotal intensity:\", round(x$total.int, digits), \"\\n\")\n  \n  cat(\"\\n\\nAverage intensity of constructs:\", round(x$c.int.mean, digits), \"\\n\")\n  cat(\"\\nItensity by construct:\\n\")\n  df.c.int <- data.frame(intensity=x$c.int)\n  rownames(df.c.int) <- paste(seq_along(x$c.int), names(x$c.int))\n  print(round(df.c.int, digits))\n  \n  cat(\"\\n\\nAverage intensity of elements:\", round(x$e.int.mean, digits), \"\\n\")\n  cat(\"\\nItensity by element:\\n\")\n  df.e.int <- data.frame(intensity=x$e.int)\n  rownames(df.e.int) <- paste(seq_along(x$e.int), names(x$e.int))\n  print(round(df.e.int, digits))\n}\n\n\n\n\n\n\n\n\n###############################################################################\n###    \t\t\t\t\t            CONFLICT MEASURES       \t\t\t\t\t\t\t          ###\n###############################################################################\n\n#' Print function for class indexConflict1\n#' \n#' @param x         Object of class indexConflict1.\n#' @param digits    Numeric. Number of digits to round to (default is \n#'                  \\code{1}).\n#' @param ...       Not evaluated.\n#' @export\n#' @method          print indexConflict1\n#' @keywords        internal\n#' \nprint.indexConflict1 <- function(x, digits=1, ...)\n{\n  cat(\"\\n################################\")\n  cat(\"\\nConflicts based on correlations\")\n  cat(\"\\n################################\") \n  cat(\"\\n\\nAs devised by Slade & Sheehan (1979)\")\n  \n  cat(\"\\n\\nTotal number of triads:\", x$total)\n  cat(\"\\nNumber of imbalanced triads:\",x$imbalanced)\n  \n  cat(\"\\n\\nProportion of balanced triads:\", \n      round(x$prop.balanced * 100, digits=digits), \"%\")\n  cat(\"\\nProportion of imbalanced triads:\", \n      round(x$prop.imbalanced * 100, digits=digits), \"%\")\n}\n\n\n#' Conflict measure as proposed by Slade and Sheehan (1979) \n#'\n#' The first approach to mathematically derive a conflict measure based on\n#' grid data was presented by Slade and Sheehan (1979). Their \n#' operationalization is based on an approach by Lauterbach (1975) \n#' who applied the \\emph{balance theory} (Heider, 1958) for a quantitative \n#' assessment of psychological conflict. It is based on a count of \n#' balanced and imbalanced triads of construct correlations.\n#' A triad is imbalanced if one or all three of the correlations are \n#' negative, i. e. leading to contrary implications. This approach \n#' was shown by Winter (1982) to be flawed. An improved version was \n#' proposed by Bassler et al. (1992) and has been implemented\n#' in the function \\code{indexConflict2}.\n#'\n#' The table below shows when a triad made up of the constructs\n#' A, B, and C is balanced and imbalanced.\n#'\n#' \\tabular{cccc}{\n#'  cor(A,B) \\tab  cor(A,C) \\tab  cor(B,C) \\tab  Triad characteristic \\cr\n#'  +   \\tab  +   \\tab  +   \\tab   balanced               \\cr\n#'  +   \\tab  +   \\tab  -   \\tab   imbalanced             \\cr\n#'  +   \\tab  -   \\tab  +   \\tab   imbalanced             \\cr\n#'  +   \\tab  -   \\tab  -   \\tab   balanced               \\cr\n#'  -   \\tab  +   \\tab  +   \\tab   imbalanced             \\cr\n#'  -   \\tab  +   \\tab  -   \\tab   balanced               \\cr\n#'  -   \\tab  -   \\tab  +   \\tab   balanced               \\cr\n#'  -   \\tab  -   \\tab  -   \\tab   imbalanced             \\cr\n#' }\n#'\n#' @title         Conflict measure for grids (Slade & Sheehan, 1979) based on correlations.\n#'\n#' @param x       \\code{repgrid} object.\n#' @return        A list with the following elements:\n#' \n#'    \\item{total}{Total number of triads} \n#'    \\item{imbalanced}{Number of imbalanced triads} \n#'    \\item{prop.balanced}{Proportion of balanced triads} \n#'    \\item{prop.imbalanced}{Proportion of imbalanced triads} \n#'\n#' @references    Bassler, M., Krauthauser, H., & Hoffmann, S. O. (1992). \n#'                A new approach to the identification of cognitive conflicts \n#'                in the repertory grid: An illustrative case study. \n#'                \\emph{Journal of Constructivist Psychology, 5}(1), 95-111.\n#'\n#'                Heider, F. (1958). \\emph{The Psychology of Interpersonal Relation}.\n#'                John Wiley & Sons.\n#'\n#'                Lauterbach, W. (1975). Assessing psychological conflict. \n#'                \\emph{The British Journal of Social and Clinical Psychology, 14}(1), 43-47.\n#'\n#'                Slade, P. D., & Sheehan, M. J. (1979). The measurement of \n#'                'conflict' in repertory grids. \\emph{British Journal \n#'                of Psychology, 70}(4), 519-524.\n#'  \n#'                Winter, D. A. (1982). Construct relationships, psychological \n#'                disorder and therapeutic change. \\emph{The British Journal of \n#'                Medical Psychology, 55} (Pt 3), 257-269.\n#' \n#' @author        Mark Heckmann\n#' @export\n#' @seealso \\code{\\link{indexConflict2}} for an improved version of this measure;\n#'          see \\code{\\link{indexConflict3}} for a measure based on distances.\n#'\n#' @examples \\dontrun{\n#'    \n#'    indexConflict1(feixas2004)\n#'    indexConflict1(boeker)\n#'\n#' }\n#'\nindexConflict1 <- function(x) {\n  if (!inherits(x, \"repgrid\")) \n\t\tstop(\"Object must be of class 'repgrid'\")\n\tr <- constructCor(x)                    # construct correlation matrix\n\tz <- fisherz(r)\n\tnc <- getNoOfConstructs(x)              # number of constructs\n\tcomb <- t(combn(nc, 3))                 # all possible correlation triads\n\tbalanced <- rep(NA, nrow(comb))         # set up result vector\n\t\n\tfor (i in 1:nrow(comb)){\n  \tz.triad <- z[t(combn(comb[i, ], 2))]  # correlations of triad\n  \tz.prod <- prod(z.triad)\n  \tif (sign(z.prod) > 0)   # triad is imbalanced if product of correlations is negative\n  \t  balanced[i] <- TRUE else\n  \t  balanced[i] <- FALSE\n\t} \n\tprop.balanced <- sum(balanced) / length(balanced)    # proportion of \n\tprop.imbalanced <- 1 - prop.balanced                                # proportion of \n\t\n\tres <- list(total=length(balanced),\n\t            imbalanced=sum(!balanced),\n\t            prop.balanced=prop.balanced, \n\t            prop.imbalanced=prop.imbalanced)\n  class(res) <- \"indexConflict1\"\n\tres\n}\n\n\n#' Conflict measure as proposed by Bassler et al. (1992). \n#'\n#' The function calculates the conflict measure as devised\n#' by Bassler et al. (1992). It is an improved version of the ideas\n#' by Slade and Sheehan (1979) that have been implemented in\n#' the function \\code{\\link{indexConflict1}}. The new approach \n#' also takes into account the magnitude of the correlations in\n#' a traid to assess whether it is balanced or imbalanced. \n#' As a result, small correlations that are psychologically meaningless\n#' are considered accordingly. Also, correlations with a  small magnitude, \n#' i. e. near zero, which may  be positive or negative due to \n#' chance alone will no longer distort the measure (Bassler et al., 1992).\n#' \n#'\n#' Description of the balance / imbalance assessment:\n#'\n#' \\enumerate{\n#'    \\item   Order correlations of the triad by absolute magnitude, so that\n#'            \\eqn{ r_{max} > r_{mdn} > r_{min} }{r_max > r_mdn > r_min}.\n#'    \\item   Apply Fisher's Z-transformation and devision by 3\n#'            to yield values between 1 and -1  \n##            (\\eqn{ Z_{max} > Z_{mdn} > Z_{min} }{Z_max > Z_mdn > Z_min}).\n#'    \\item   Check whether the triad is balanced by assessing if the \n#'            following relation holds:\n#'    \\itemize{\n#'        \\item   If \\eqn{ Z_{max} Z_{mdn} > 0 }{ Z_max x Z_mdn > 0}, \n#'                the triad is balanced if \\eqn{ Z_{max} Z_{mdn} - Z_{min} <= crit }\n#'                { Z_max x Z_mdn - Z_min <= crit }.\n#'        \\item   If \\eqn{ Z_{max} Z_{mdn} < 0 }{ Z_max x Z_mdn < 0}, \n#'                the triad is balanced if \\eqn{ Z_{min}  - Z_{max} Z_{mdn} <= crit }\n#'                { Z_min - Z_max x Z_mdn <= crit }.\n#'    }        \n#'  }\n#'\n#' @section Personal remarks (MH): I am a bit suspicious about step 2 from above. To devide by 3 appears pretty arbitrary.\n#'        The r for a z-values of 3 is 0.9950548 and not 1.\n#'        The r for 4 is 0.9993293. Hence, why not a value of 4, 5, or 6?\n#'        Denoting the value to devide by with \\code{a}, the relation for the\n#'        first case translates into \\eqn{ a  Z_{max}  Z_{mdn} <= \\frac{crit}{a} + Z_{min} }\n#'        { a x Z_max x Z_mdn =< crit/a + Z_min}. This shows that a bigger value of \\code{a}\n#'        will make it more improbabale that the relation will hold.\n#'\n#'\n#' @title         Conflict measure for grids (Bassler et al., 1992) based on correlations.\n#'\n#' @param x       \\code{repgrid} object.\n#' @param crit    Sensitivity criterion with which triads are marked as \n#'                unbalanced. A bigger values willl lead to less imbalanced \n#'                triads. The default is \\code{0.03}. The value should\n#'                be adjusted with regard to the researchers interest.\n#' @references    Bassler, M., Krauthauser, H., & Hoffmann, S. O. (1992). \n#'                A new approach to the identification of cognitive conflicts \n#'                in the repertory grid: An illustrative case study. \n#'                \\emph{Journal of Constructivist Psychology, 5}(1), 95-111.\n#'\n#'                Slade, P. D., & Sheehan, M. J. (1979). The measurement of \n#'                'conflict' in repertory grids. \\emph{British Journal \n#'                of Psychology, 70}(4), 519-524.\n#'\n#' @author        Mark Heckmann\n#' @export\n#' @seealso       See \\code{\\link{indexConflict1}} for the older version \n#'                of this measure; see \\code{\\link{indexConflict3}} \n#'                for a measure based on distances instead of correlations.\n#'\n#' @examples \\dontrun{\n#'\n#'  indexConflict2(bell2010)\n#'   \n#'  x <- indexConflict2(bell2010)  \n#'  print(x)\n#'  \n#'  # show conflictive triads\n#'  print(x, output=2)\n#'  \n#'  # accessing the calculations for further use\n#'  x$total\n#'  x$imbalanced\n#'  x$prop.balanced\n#'  x$prop.imbalanced\n#'  x$triads.imbalanced\n#' }\n#' \nindexConflict2 <- function(x, crit=.03){\n  if (!inherits(x, \"repgrid\")) \n\t\tstop(\"Object must be of class 'repgrid'\")\n\tr <- constructCor(x)                    # construct correlation matrix\n\tz <- fisherz(r)\n\tnc <- getNoOfConstructs(x)              # number of constructs\n\tcomb <- t(combn(nc, 3))                 # all possible correlation triads\n\tbalanced <- rep(NA, nrow(comb))         # set up result vector\n\t\n\tfor (i in 1:nrow(comb)){\t\n  \tz.triad <- z[t(combn(comb[i, ], 2))]      # z-values of triad\n  \tind <- order(abs(z.triad), decreasing=T)  # order for absolute magnitude\n  \tz.triad <- z.triad[ind]               # reorder z values by magnitude               \n  \tz.12 <- prod(z.triad[1:2])            # product of two biggest z values\n  \tz.3 <- z.triad[3]                     # minimal absolute z value\n  \t# select case for inequality relation assessment\n  \tif (sign(z.12) > 0) {\n  \t  balanced[i] <- z.12 - z.3 <= crit\n  \t} else {\n  \t  balanced[i] <- z.3 - z.12 <= crit\n  \t}  \n\t} \n\tprop.balanced <- sum(balanced) / length(balanced)    # proportion of \n\tprop.imbalanced <- 1 - prop.balanced                 # proportion of \n\n\tres <- list(total=length(balanced),\n  \t          imbalanced=sum(!balanced),\n  \t          prop.balanced=prop.balanced, \n\t            prop.imbalanced=prop.imbalanced,\n\t            triads.imbalanced=comb[!balanced, ])\n  class(res) <- \"indexConflict2\"\n\tres\n}\n\n\nindexConflict2Out1 <- function(x, digits=1) {\n  cat(\"\\n###############################\")\n  cat(\"\\nConflicts based on correlations\")\n  cat(\"\\n###############################\") \n  cat(\"\\n\\nAs devised by Bassler et al. (1992)\")\n  \n  cat(\"\\n\\nTotal number of triads:\", x$total)\n  cat(\"\\nNumber of imbalanced triads:\", x$imbalanced)  \n  cat(\"\\n\\nProportion of balanced triads:\", \n      round(x$prop.balanced * 100, digits=digits), \"%\")\n  cat(\"\\nProportion of imbalanced triads:\", \n      round(x$prop.imbalanced * 100, digits=digits), \"%\\n\")\n}\n\n\nindexConflict2Out2 <- function(x) {\n  cat(\"\\nConstructs that form imbalanced triads:\\n\")\n  df <- as.data.frame(x$triads.imbalanced)\n  colnames(df) <- c(\" \", \"  \", \"   \")\n  print(df)\n}\n\n\n#' Print method for class indexConflict2\n#' \n#' @param x       A \\code{repgrid} object.\n#' @param digits  Numeric. Number of digits to round to (default is \n#'                \\code{1}).\n#' @param output  Numeric. The output printed to the console. \\code{output=1} (default) \n#'                will print information about the conflicts to the console.\n#'                \\code{output=2} will additionally print the conflictive\n#'                triads. \n#' @param ...     Not evaluated.\n#' @export\n#' @method        print indexConflict2\n#' @keywords      internal\n#'\nprint.indexConflict2 <- function(x, digits=1, output=1, ...){\n  indexConflict2Out1(x, digits=digits) \n  if (output == 2) \n    indexConflict2Out2(x)\n} \n\n\n\n#' Conflict measure as proposed by Bell (2004). \n#'\n#' Measure of conflict or inconsistency as proposed by Bell (2004).\n#' The identification of conflict is based on distances rather than \n#' correlations as in other measures of conflict \\code{\\link{indexConflict1}}\n#' and \\code{\\link{indexConflict2}}. It assesses if the \n#' distances between all components of a triad, made up of one element \n#' and two constructs, satisfies the \"triangle inequality\" (cf. Bell, 2004).\n#' If not, a triad is regarded as conflictive. An advantage of the measure \n#' is that it can be interpreted not only as a global measure for a \n#' grid but also on an element, construct, and element by construct level \n#' making it valuable for detailed feedback. Also, differences in conflict \n#' can be submitted to statistical testing procedures.\n#'\n#' Status:  working; output for euclidean and manhattan distance \n#'          checked against Gridstat output. \\cr\n#' TODO:    standardization and z-test for discrepancies; \n#'          Index of Conflict Variation.\n#'\n#' @title       Conflict or inconsistenciy measure for grids (Bell, 2004) based on distances.\n#'\n#' @param x             \\code{repgrid} object.\n#' @param p             The power of the Minkowski distance. \\code{p=2} (default) will result\n#'                      in euclidean distances, \\code{p=1} in city block\n#'                      distances.\n#' @param e.out         Numeric. A vector giving the indexes of the elements\n#'                      for which detailed stats (number of conflicts per element,\n#'                      discrepancies for triangles etc.) are promted \n#'                      (default \\code{NA}, i.e. no detailed stats for any element).\n#' @param e.threshold   Numeric. Detailed stats are prompted for those elements with a an \n#'                      attributable percentage to the overall conflicts \n#'                      higher than the supplied threshold\n#'                      (default \\code{NA}).\n#' @param c.out         Numeric. A vector giving the indexes of the constructs\n#'                      for which detailed stats (discrepancies for triangles etc.) \n#'                      are promted (default \\code{NA}, i. e. no detailed stats).\n#' @param c.threshold   Numeric. Detailed stats are prompted for those constructs with a an \n#'                      attributable percentage to the overall conflicts \n#'                      higher than the supplied threshold\n#'                      (default \\code{NA}).\n#' @param trim          The number of characters a construct (element) is trimmed to (default is\n#'                      \\code{10}). If \\code{NA} no trimming is done. Trimming\n#'                      simply saves space when displaying the output.\n#'\n#' @return              A list (invisibly) containing containing: \\cr\n#'                      \\item{potential}{number of potential conflicts}\n#'                      \\item{actual}{count of actual conflicts}\n#'                      \\item{overall}{percentage of conflictive relations}\n#'                      \\item{e.count}{number of involvements of each element in conflictive relations}\n#'                      \\item{e.perc}{percentage of involvement of each element in total of conflictive relations}\n#'                      \\item{e.count}{number of involvements of each construct in conflictive relation}\n#'                      \\item{c.perc}{percentage of involvement of each construct in total of conflictive relations}\n#'                      \\item{e.stats}{detailed statistics for prompted elements}\n#'                      \\item{c.stats}{detailed statistics for prompted constructs}                     \n#'                      \\item{e.threshold}{threshold percentage. Used by print method}\n#'                      \\item{c.threshold}{threshold percentage. Used by print method}\n#'                      \\item{enames}{trimmed element names. Used by print method}\n#'                      \\item{cnames}{trimmed construct names. Used by print method}\n#'\n#' @references    Bell, R. C. (2004). A new approach to measuring inconsistency \n#'                or conflict in grids. Personal Construct Theory & Practice, \n#'                (1), 53-59.\n#' @section output: For further control over the output see \\code{\\link{print.indexConflict3}}.\n#' @author        Mark Heckmann\n#' @export\n#' @seealso       See \\code{\\link{indexConflict1}} and \\code{\\link{indexConflict2}} \n#'                for conflict measures based on triads of correlations.\n#'\n#' @examples \\dontrun{\n#'\n#'  # calculate conflicts\n#'  indexConflict3(bell2010)\n#'  \n#'  # show additional stats for elements 1 to 3\n#'  indexConflict3(bell2010, e.out=1:3)\n#'  \n#'  # show additional stats for constructs 1 and 5\n#'  indexConflict3(bell2010, c.out=c(1,5))\n#'  \n#'  # finetune output\n#'  ## change number of digits\n#'  x <- indexConflict3(bell2010)\n#'  print(x, digits=4)\n#'\n#'  ## omit discrepancy matrices for constructs\n#'  x <- indexConflict3(bell2010, c.out=5:6)\n#'  print(x, discrepancies=FALSE)\n#'  \n#' }\n#'\n#'\nindexConflict3 <- function(x, p=2,  \n                           e.out=NA, e.threshold=NA,\n                           c.out=NA, c.threshold=NA,\n                           trim=20) {\n  # To assess the triangle inequality we need:\n  #\n  # - d.ij   'distance'  between element i and constuct j\n  # - d.ik   'distance'  between element i and constuct k\n  # - d.jk   distance between the constructs j and k\n  #\n  # Let the distance between element i and a construct j (i.e. d.ij)\n  # be the rating of element i on construct j.\n  # The distance between the constucts it the distance (euclidean or city block)\n  # between them without taking into account the element under consideration.\n\n  s <- getRatingLayer(x)            # grid scores matrix\n  ne <- getNoOfElements(x)\n  nc <- getNoOfConstructs(x)\n  enames <- getElementNames2(x, index=T, trim=trim,  pre=\"\", post=\" \")\n  cnames <- getConstructNames2(x, index=T, trim=trim, mode=1, pre=\"\", post=\" \")\n\n  # set up result vectors\n  # confict.disc      discrepancy for each triangle (indexed e, c1, c2)\n  # confict.e         number of conflicts for each element\n  # conflict.c        number of conflicts for each construct\n  # conflict.total    overall value of conflictive triangles\n  conflict.disc  <- array(NA, dim=c(nc, nc, ne))\n  conflict.e  <- rep(0, ne)\n  conflict.c  <- rep(0, nc)\n  conflict.total <- 0\n  conflicts.potential <-  ne * nc *(nc -1)/2\n  # e is i, c1 is j and c2 is k in Bell's Fortran code\n\n  for (e in seq_len(ne)){\n    # average distance between constructs c1 and c2 not taking into account\n    # the element under consideration. Generalization for any minkwoski metric\n    dc <- dist(s[, -e], method=\"minkowski\", p=p) / (ne - 1)^(1/p)     # Bell averages the unsquared distances (euclidean), \n    dc <- as.matrix(dc)   # convert dist object to matrix             # i.e. divide euclidean dist by root of n or p in the general case\n\n    for (c1 in seq_len(nc)){\n      for (c2 in seq_len(nc)){\n        if (c1 < c2){\n          d.jk <- dc[c1, c2]\n          d.ij <- s[c1, e]\n          d.ik <- s[c2, e]\n\n          # assess if triangle inequality fails., i.e. if one distance is bigger \n          # than the sum of the other two distances. The magnitude it is bigger\n          # is recorded in disc (discrepancy)\n          if (d.ij > (d.ik + d.jk))\n            disc <- d.ij-(d.ik + d.jk) else \n          if (d.ik > (d.ij + d.jk))\n            disc <- d.ik-(d.ij + d.jk) else \n          if (d.jk > (d.ij + d.ik))\n            disc <- d.jk - (d.ij + d.ik) else \n          disc <- NA\n\n          # store size of discrepancy in confict.disc and record discrepancy\n          # by element (confict.e) construct (confict.c) and overall (confict.total)\n          if (!is.na(disc)){\n            conflict.disc[c1, c2, e]  <- disc\n            conflict.disc[c2, c1, e]  <- disc\n            conflict.e[e]  <- conflict.e[e] + 1       \n            conflict.c[c1]  <- conflict.c[c1] + 1\n            conflict.c[c2]  <- conflict.c[c2] + 1\n            conflict.total <- conflict.total + 1\n          }\n        }\n      }   \n    }\n  }\n\n  # add e and c names to results\n  dimnames(conflict.disc)[[3]] <- enames  \n  conflict.e.df <- data.frame(percentage=conflict.e)\n  rownames(conflict.e.df) <- enames\n  conflict.c.df <- data.frame(percentage=conflict.c)\n  rownames(conflict.c.df) <- cnames\n  \n  \n  ### Detailed stats for elements ###\n  \n  conflictAttributedByConstructForElement <- function(e){\n    e.disc.0 <- e.disc.na <- conflict.disc[ , , e]          # version with NAs and zeros for no discrepancies\n    e.disc.0[is.na(e.disc.0)] <- 0                          # replace NAs by zeros\n      \n    e.disc.no <- apply(!is.na(e.disc.na), 2, sum)           # number of conflicts per construct   \n    e.disc.perc <- e.disc.no / sum(e.disc.no) * 100         # no conf. per as percentage\n    e.disc.perc.df <- data.frame(percentage=e.disc.perc)      # convert to dataframe\n    rownames(e.disc.perc.df) <- cnames                      # add rownames\n    \n    n.conflict.pairs <-  sum(e.disc.no) / 2                 # number of conflicting construct pairs all elements\n    disc.avg <- mean(e.disc.0)                              # average level of discrepancy\n    disc.sd <- sd(as.vector(e.disc.na), na.rm=T)            # sd of discrepancies\n    \n    disc.stand <- (e.disc.na - disc.avg) / disc.sd          # standardized discrepancy\n    \n    list(e=e, \n         disc=e.disc.na,\n         pairs=n.conflict.pairs,\n         constructs=e.disc.perc.df,\n         avg=disc.avg,\n         sd=disc.sd)#,\n         #disc.stand=round(disc.stand, digits))\n  }\n  \n  \n  ### Detailed stats for constructs ###\n\n  conflictAttributedByElementForConstruct <- function(c1) {\n    c1.disc.0 <- c1.disc.na <- conflict.disc[c1, , ]     # version with NAs and zeros for no discrepancies\n    rownames(c1.disc.na) <- paste(\"c\", seq_len(nrow(c1.disc.na)))\n    colnames(c1.disc.na) <- paste(\"e\", seq_len(ncol(c1.disc.na)))\n    \n    c1.disc.0[is.na(c1.disc.0)] <- 0                     # replace NAs by zeros\n    \n    disc.avg <- mean(c1.disc.0)                          # average level of discrepancy\n    disc.sd <- sd(as.vector(c1.disc.na), na.rm=T)        # sd of discrepancies\n    list(c1=c1, \n         disc=c1.disc.na,\n         avg=disc.avg,\n         sd=disc.sd)#,\n          #disc.stand=round(disc.stand, digits))\n  }\n  \n  # Select which detailed stats for elements. Either all bigger than\n  # a threshold or the ones selected manually.\n  if (!is.na(e.out[1]))\n    e.select <- e.out else \n  if (!is.na(e.threshold[1]))\n    e.select <- which(conflict.e/conflict.total *100 > e.threshold) else\n  e.select <- NA\n  \n  e.stats <- list()               # list with detailed results\n  if (!is.na(e.select[1])){\n    for (e in seq_along(e.select))\n      e.stats[[e]] <- conflictAttributedByConstructForElement(e.select[e]) \n    names(e.stats) <- enames[e.select]   \n  }\n \n  # Select which detailed stats for constructs. Either all bigger than\n  # a threshold or the ones selected manually.\n  if (!is.na(c.out[1]))\n    c.select <- c.out else \n  if (!is.na(c.threshold[1]))\n    c.select <- which(.5*conflict.c/conflict.total *100 > c.threshold) else\n  c.select <- NA\n\n  c.stats <- list()               # list with detailed results\n  if (!is.na(c.select[1])){\n    for (c in seq_along(c.select))\n      c.stats[[c]] <- conflictAttributedByElementForConstruct(c.select[c])\n    names(c.stats) <- cnames[c.select]   \n  }\n     \n  res <- list(potential = conflicts.potential,\n              actual = conflict.total,  \n              overall = conflict.total/conflicts.potential * 100,\n              e.count = conflict.e,\n              e.perc = conflict.e.df / conflict.total * 100,\n              c.count= conflict.c,\n              c.perc = .5 * conflict.c.df / conflict.total * 100,\n              e.stats = e.stats,\n              c.stats = c.stats,\n              e.threshold = e.threshold,    # threshold for elements\n              c.threshold = c.threshold,\n              enames=enames,                # element names\n              cnames=cnames)\n  class(res) <- \"indexConflict3\"\n  res\n}\n\n\n### Output to console ###\nindexConflict3Out1 <- function(x, digits=1) {\n  cat(\"\\n##########################################################\")\n  cat(\"\\nCONFLICT OR INCONSISTENCIES BASED ON TRIANGLE INEQUALITIES\")\n  cat(\"\\n##########################################################\\n\")\n  cat(\"\\nPotential conflicts in grid: \", x$potential)\n  cat(\"\\nActual conflicts in grid: \", x$actual) \n  cat(\"\\nOverall percentage of conflict in grid: \", \n      round(x$actual / x$potential * 100, digits), \"%\\n\") \n  \n  cat(\"\\nELEMENTS\")\n  cat(\"\\n########\\n\")\n  cat(\"\\nPercent of conflict attributable to element:\\n\\n\")\n  print(round(x$e.perc * 100, digits)) \n  cat(\"\\nChi-square test of equal count of conflicts for elements.\\n\")\n  print(chisq.test(x$e.count))\n  \n  cat(\"\\nCONSTRUCTS\")\n  cat(\"\\n##########\\n\")\n  cat(\"\\nPercent of conflict attributable to construct:\\n\\n\")\n  print(round(x$c.perc , digits))\n  cat(\"\\nChi-square test of equal count of conflicts for constructs.\\n\")\n  print(chisq.test(x$c.count))\n  #print(sd(conflict.c.perc))\n  #print(var(conflict.c.perc))    \n}\n\n\nindexConflict3Out2 <- function(x, digits=1, discrepancies=TRUE) {\n  e.stats <- x$e.stats\n  e.threshold <- x$e.threshold\n  enames <- x$enames\n  \n  if (length(e.stats) == 0)     # stop function in case  \n    return(NULL)\n  \n  cat(\"\\n\\nCONFLICTS BY ELEMENT\")\n  cat(\"\\n####################\\n\")\n  if (!is.na(e.threshold))\n    cat(\"(Details for elements with conflict >\", e.threshold, \"%)\\n\")\n  \n  for (e in seq_along(e.stats)){\n    m <- e.stats[[e]]\n    if (!is.null(m)){\n      cat(\"\\n\\n### Element: \", enames[m$e], \"\\n\")\n      cat(\"\\nNumber of conflicting construct pairs: \", m$pairs, \"\\n\")\n      if (discrepancies){\n        cat(\"\\nConstruct conflict discrepancies:\\n\\n\")\n        disc <- round(m$disc, digits)\n        print(as.data.frame(formatMatrix(disc, rnames=\"\", \n                                         mode=2, diag=F), stringsAsFactors=F))\n      }\n      cat(\"\\nPercent of conflict attributable to each construct:\\n\\n\")    \n      print(round(m$constructs, digits))\n      cat(\"\\nAv. level of discrepancy:   \", round(m$avg, digits), \"\\n\")\n      cat(\"\\nStd. dev. of discrepancies: \", round(m$sd, digits + 1), \"\\n\")\n    }\n  }\n}\n\n\nindexConflict3Out3 <- function(x, digits=1, discrepancies=TRUE) \n{\n  c.threshold <- x$c.threshold\n  c.stats <- x$c.stats\n  cnames <- x$cnames\n  \n  if (length(c.stats) == 0)     # stop function in case  \n    return(NULL)\n  \n  cat(\"\\n\\nCONFLICTS BY CONSTRUCT\")\n  cat(\"\\n######################\\n\")\n  if (!is.na(c.threshold))\n    cat(\"(Details for constructs with conflict >\", c.threshold, \"%)\\n\")\n  \n  for (c in seq_along(c.stats)) {\n    x <- c.stats[[c]]\n    if (!is.null(x)) {\n      cat(\"\\n\\n### Construct: \", cnames[x$c1], \"\\n\")\n      if (discrepancies) {\n        cat(\"\\nElement-construct conflict discrepancies:\\n\\n\")\n        disc <- round(x$disc, digits)\n        print(as.data.frame(formatMatrix(disc, \n                                         rnames=paste(\"c\", seq_len(nrow(x$disc)), sep=\"\"), \n                                         cnames=paste(\"e\", seq_len(ncol(x$disc)), sep=\"\"),\n                                         pre.index=c(F,F),\n                                         mode=2, diag=F), stringsAsFactors=F))\n      }\n      cat(\"\\nAv. level of discrepancy:   \", round(x$avg, digits), \"\\n\")\n      cat(\"\\nStd. dev. of discrepancies: \", round(x$sd, digits + 1), \"\\n\")\n    }\n  }\n}\n\n\n#' print method for class indexConflict3\n#' \n#' @param x             Output from funtion indexConflict3\n#' @param output        Type of output. \\code{output=1} will print all results\n#'                      to the console, \\code{output=2} will only print the\n#'                      detailed statistics for elements and constructs. \n#' @param digits        Numeric. Number of digits to round to (default is \n#'                      \\code{2}).\n#' @param discrepancies Logical. Whether to show matrices of discrepancies in \n#'                      detailed element and construct stats (default \\code{TRUE}).\n#' @param ...           Not evaluated.\n#' @export\n#' @method              print indexConflict3\n#' @keywords            internal\n#'                    \nprint.indexConflict3 <- function(x, digits=2, output=1, discrepancies=TRUE, ...)\n{\n  if (output == 1)\n    indexConflict3Out1(x, digits=digits) \n  indexConflict3Out2(x, digits=digits, discrepancies=discrepancies)\n  indexConflict3Out3(x, digits=digits, discrepancies=discrepancies) \n}\n\n\n# plots distribution of construct correlations\n#\nindexDilemmaShowCorrelationDistribution <- function(x, e1, e2)\n{\n  rc.including <- constructCor(x)  \n  rc.excluding <- constructCor(x[, -c(e1, e2)])\n  rc.inc.vals <- abs(rc.including[lower.tri(rc.including)])\n  rc.exc.vals <- abs(rc.excluding[lower.tri(rc.excluding)])\n\n  histDensity <- function(vals, probs=c(.2, .4, .6, .8, .9), ...){\n    h <- hist(vals, breaks=seq(0, 1.01, len=21), freq=F, \n              xlim=c(0, 1), border=\"white\", col=grey(.8), ...)\n    d <- density(vals)\n    lines(d$x, d$y)\n    q <- quantile(vals, probs=probs)\n    abline(v=q, col=\"red\")\n    text(q, 0, paste(round(probs*100, 0), \"%\"), cex=.8, pos=2, col=\"red\")  \n  }\n\n  layout(matrix(c(1,2), ncol=1))\n  par(mar=c(3,4.2,2.4,2))\n  histDensity(rc.inc.vals, cex.main=.8, cex.axis=.8, cex.lab=.8,\n              main=\"Distribution of absolute construct-correlations \\n(including 'self' and 'ideal self')\")\n  histDensity(rc.exc.vals,  cex.main=.8, cex.axis=.8, cex.lab=.8, \n              main=\"Distribution of absolute construct-correlations \\n(excluding 'self' and 'ideal self')\")\n}\n\n\n# internal workhorse for indexDilemma\n#\n# @param x               \\code{repgrid} object.\n# @param self            Numeric. Index of self element.\n# @param ideal           Numeric. Index of ideal self element. \n# @param diff.mode       Numeric. Mode to classify construct pairs into congruent and\n#                        discrepant. \\code{diff.mode=1} will use the difference in \n#                        ratings between the self and the ideal element to determine if\n#                        the construct is congruent or discrepant. No other\n#                        modes have yet been implemented.\n# @param diff.congruent  Is used if \\code{diff.mode=1}. Maximal difference between\n#                        element ratings to define construct as congruent (default\n#                        \\code{diff.congruent=1}). Note that the value\n#                        needs to be adjusted by the user according to the rating scale\n#                        used.\n# @param diff.discrepant Is used if \\code{diff.mode=1}. Minimal difference between\n#                        element ratings to define construct as discrepant (default\n#                        \\code{diff.discrepant=4}). Note that the value\n#                        needs to be adjusted by the user according to the rating scale\n#                        used.\n# @param diff.poles      Not yet implemented.\n# @param r.min           Minimal correlation to determine implications between\n#                        constructs.\n# @param exclude         Whether to exclude the elements self and ideal self \n#                        during the calculation of the inter-construct correlations.\n#                        (default is \\code{FALSE}).\n# @param index           Whether to print index numbers in front of each construct \n#                        (default is \\code{TRUE}).\n# @param trim            The number of characters a construct (element) is trimmed to (default is\n#                        \\code{20}). If \\code{NA} no trimming is done. Trimming\n#                        simply saves space when displaying the output.\n# @param digits          Numeric. Number of digits to round to (default is \n#                        \\code{2}).\n# @author                Mark Heckmann\n# @export\n# @keywords internal\n# @return                A list with four elements containing different steps of the \n#                        calculation.\n#\nindexDilemmaInternal <- function(x, self, ideal, \n                            diff.mode = 1, diff.congruent = 0,\n                            diff.discrepant = 4, diff.poles=1, \n                            r.min=.35, exclude=FALSE, digits=2,\n                            index=T, trim=NA)\n{\n  s <- getRatingLayer(x)         # grid scores matrix\n  nc <- getNoOfConstructs(x)\n  cnames <- getConstructNames2(x, index=index, trim=trim, mode=1, pre=\"\", post=\" \")\n\n  # inter-construct correlations including and excluding \n  # the elements self and ideal self\n  rc.include <- constructCor(x)                     # TODO digits=digits\n  rc.exclude <- constructCor(x[, -c(self, ideal)])  #digits=digits\n  \n  # correlations to use for evaluation\n  if (exclude)\n    rc.use <- rc.exclude else\n    rc.use <- rc.include\n  \n  type.c.poles <- type.c.elem <- rep(NA, nrow(s)) # set up reults vectors\n\n  # difference self - ideal self  \n  diff.between <- abs(s[, self] - s[, ideal])\n  is.congruent.e <- diff.between <= diff.congruent\n  is.discrepant.e <- diff.between >= diff.discrepant\n  is.neither.e <- !is.congruent.e & !is.discrepant.e \n  type.c.elem[is.congruent.e] <- \"congruent\"\n  type.c.elem[is.discrepant.e] <- \"discrepant\"\n  type.c.elem[is.neither.e] <- \"neither\"\n\n  # # difference from poles NOT YET IMPLEMENTED\n  # sc <- getScale(x)\n  # diff.pole1 <- abs(s[, c(e.self, e.ideal)] - sc[1])\n  # diff.pole2 <- abs(s[, c(e.self, e.ideal)] - sc[2])\n  # #are both elements within the allowed distance from the poles and at the same pole (congruent)\n  # is.congruent.p <- diff.pole1[,1] <= diff.poles & diff.pole1[,2] <= diff.poles |\n  #                   diff.pole2[,1] <= diff.poles & diff.pole2[,2] <= diff.poles\n  # is.discrepant.p <- diff.pole1[,1] <= diff.poles & diff.pole2[,2] <= diff.poles |\n  #                     diff.pole1[,1] <= diff.poles & diff.pole2[,2] <= diff.poles\n  # \n  # is.neither.p <- !is.congruent.p & !is.discrepant.p \n  # type.c.poles[is.congruent.p] <- \"congruent\"\n  # type.c.poles[is.discrepant.p] <- \"discrepant\"\n  # type.c.poles[is.neither.p] <- \"neither\"\n  \n  if (diff.mode == 1){\n    is.congruent <- is.congruent.e\n    is.discrepant <- is.discrepant.e\n    type.construct <- type.c.elem\n  } else {\n    # is.congruent <- is.congruent.p\n    # is.discrepant <- is.discrepant.p\n    # type.construct <- type.c.poles \n  }\n  res1 <- data.frame(a.priori=type.c.elem, self=s[, self], ideal=s[, ideal],\n                      stringsAsFactors=F)\n  colnames(res1) <- c(\"A priori\", \"Self\", \"Ideal\")\n  rownames(res1) <- cnames\n\n  # which pairs of absolute construct correlations are bigger than r.min?\n  comb <- t(combn(nc, 2))                       # all possible correlation pairs\n  # set up result vectors\n  check <- bigger.rmin <- r.include <- r.exclude <- \n      check <- type.c1 <- type.c2 <- rep(NA, nrow(comb))          \n\n  # check every pair of constructs for characteristics\n  for (i in 1:nrow(comb)){\n    c1 <-\tcomb[i,1]\n    c2 <- comb[i,2]\n    r.include[i] <- rc.include[c1, c2]\n    r.exclude[i] <- rc.exclude[c1, c2]\n    type.c1[i] <- type.construct[c1]\n    type.c2[i] <- type.construct[c2]\n\n    if (abs(rc.use[c1, c2]) >= r.min)\n       bigger.rmin[i] <- TRUE else\n       bigger.rmin[i] <- FALSE\n\n    check[i] <- (is.congruent[c1] & is.discrepant[c2]) |\n             (is.discrepant[c1] & is.congruent[c2]) \n  }  \n  \n  res2 <- data.frame(c1=comb[,1], c2=comb[,2], r.inc=r.include, \n                    r.exc=r.exclude, bigger.rmin, type.c1, type.c2, check,\n                    name.c1=cnames[comb[,1]], name.c2=cnames[comb[,2]], \n                    stringsAsFactors=F) \n                      \n  res3 <- subset(res2, bigger.rmin==T & check==T)  \n  \n  # add asteristic to construct names\n  ids <- res3\n  disc.c1 <- ids$type.c1 == \"discrepant\"\n  disc.c2 <- ids$type.c2 == \"discrepant\"\n  ids$name.c1[disc.c1] <- paste(ids$name.c1[disc.c1], \"*\", sep=\"\")\n  ids$name.c2[disc.c2] <- paste(ids$name.c2[disc.c2], \"*\", sep=\"\")\n  res4 <- data.frame(RexSI=ids[,3], Rtot=ids[,4],\n                    Constructs=paste(ids[,9], ids[,10], sep=\" <==> \"))                \n  list(res1=res1, res2=res2, res3=res3, res4=res4)\n}\n\n\n# output function for indexDilemma\n#\nindexDilemmaOut0 <- function(res, self, ideal, enames, \n                             diff.discrepant, diff.congruent, exclude, r.min){\n  cat(\"\\n###################\\n\")\n  cat(\"Implicative Dilemma\")\n  cat(\"\\n###################\\n\")\n  \n  cat(\"\\nActual Self Position:\", enames[self])               \n  cat(\"\\nIdeal Self Position:\", enames[ideal])   \n\n  cat(\"\\n\\nA Priori Criteria (for classification):\")      \n  cat(\"\\nDiscrepant Difference: >=\", diff.discrepant)\n  cat(\"\\nCongruent Difference: <=\", diff.congruent)\n  \n  cat(\"\\n\\nCorrelation Criterion: >=\", r.min)\n  if (exclude)\n    cat(\"\\nCriterion Correlation excludes Self & Ideal\") else \n    cat(\"\\nCriterion Correlation includes Self & Ideal\\n\")\n\n  cat(\"\\nNumber of Implicative Dilemmas found:\", nrow(res$res4), \"\\n\")\n  #Extreme Criteria:\n  #Discrepant Difference: Self-Ideal greater than or equal to, Max Other-Self difference\n  #Congruent Difference: Self-Ideal less than or equal to, Min Other-Self difference  \n}\n\n\n# output function for indexDilemma\n#\nindexDilemmaOut1 <- function(res){\n  cat(\"\\n\\nClassification of Constructs\")\n  cat(\"\\n############################\\n\\n\")\n  print(res$res1)\n  cat(\"\\n\\tNote: Low scores correspond to the left, high scores to the right construct pole\\n\")\n}\n \n  \n# output function for indexDilemma\n#\nindexDilemmaOut2 <- function(res, exclude){\n  # add asteristic to construct names\n  # ids <- res$res3\n  #  disc.c1 <- ids$type.c1 == \"discrepant\"\n  #  disc.c2 <- ids$type.c2 == \"discrepant\"\n  #  ids$name.c1[disc.c1] <- paste(ids$name.c1[disc.c1], \"*\", sep=\"\")\n  #  ids$name.c2[disc.c2] <- paste(ids$name.c2[disc.c2], \"*\", sep=\"\")\n  cat(\"\\n\\nDilemmatic Self-Ideal Construct Pairs\")\n  cat(\"\\n#####################################\")\n  cat(\"\\n\\nBy A Priori Criteria:\\n\\n\")\n  # df <- data.frame(RexSI=ids[,3], Rtot=ids[,4],\n  #                   Constructs=paste(ids[,9], ids[,10], sep=\" <==> \"))\n  df <- res$res4\n  if (nrow(df) > 0){\n    print(df)\n    cat(\"\\n\\tRexSI = Correlations excluding Self & ideal\")\n    cat(\"\\n\\tRtot  = Correlations including Self & ideal\")\n    if (exclude)\n      cor.used <- \"RexSI\" else\n      cor.used <- \"Rtot\"\n    cat(\"\\n\\t\", cor.used, \" was used as criterion\", sep=\"\")\n    cat(\"\\n\\t\", \"* = discrepant construct pair\", sep=\"\")\n  } else {\n    cat(\"No implicative dilemmas detected\")\n  }\n}\n\n\n#' Implicative Dilemmas\n#'\n#' Implicative dilemmas are closely related to the notion of \n#' conflict. An implicative dilemma arises when a desired change on one \n#' construct is associated with an undesired \n#' implication on another construct. \n#' E. g. a timid subject may want to become more socially skilled but \n#' associates being socially skilled with different negative characteristics \n#' (selfish, insensitive etc.). Hence, he may anticipate that becoming less\n#' timid will also make him more selfish (cf. Winter, 1982). \n#' As a consequence the subject will resist to the change if the \n#' negative presumed implications will threaten the patients identity \n#' and the predictive power of his construct system. From this stance \n#' the resistance to change is a logical consequence coherent with \n#' the subjects construct system (Feixas, Saul, & Sanchez, 2000).\n#' The investigation of the role of cognitive dilemma in different disorders \n#' in the context of PCP is a current field of research \n#' (e.g. Feixas & Saul, 2004, Dorough et al. 2007).\n#'\n#' The detection of implicative dilemmas happens in two steps. First the \n#' constructs are classified as being 'congruent' or 'discrepant'. Second\n#' the correlation between a congruent and discrepant construct pair\n#' is assessed if it is big enough to indicate an implication.\n#' \n#' \\bold{Classifying the construct} \\cr\n#' To detect implicit dilemmas the construct pairs are first\n#' identified as 'congruent' or 'discrepant'. The assessment\n#' is based on the rating differences between the elements\n#' 'self' and 'ideal self'.\n#' A construct is 'congruent' if the construction of the 'self' and the \n#' preferred state (i.e. ideal self) are the same or similar. \n#' A construct is discrepant if the construction of the 'self' and \n#' the 'ideal' is dissimilar. \n#' Suppose the element 'self' is rated 2 and 'ideal self' 5 on \n#' a scale from 1 to 6. The ratings differences are 5-2 = 3. If this \n#' difference is smaller than e.g. 1 the construct is 'congruent', if it\n#' is bigger than 3 it is 'discrepant'. \\cr\n#'\n#' The values used to classify the constructs 'congruent'\n#' or 'discrepant' can be determined in several ways (cf. Bell, 2009):\n#' \\enumerate{\n#'    \\item   They are set 'a priori'.\n#'    \\item   They are implicitly derived by taking into account the rating\n#'            differences to the other constructs. \n#'            Not yet implemented.\n#' }\n#'\n#' The value mode is determined via the argument \\code{diff.mode}.\\cr\n#' If no 'a priori' criteria to determine if the construct\n#' is congruent or discrepant is supplied as an argument, the values are chosen\n#' acording to the range of the rating scale used. For the following scales\n#' the defaults are chosen as:\n#'\n#' \\tabular{ll}{\n#' Scale                \\tab 'A priori' criteria        \\cr\n#' 1 2                  \\tab --> con: <=0    disc: >=1  \\cr\n#' 1 2 3                \\tab --> con: <=0    disc: >=2  \\cr\n#' 1 2 3 4              \\tab --> con: <=0    disc: >=2  \\cr\n#' 1 2 3 4 5            \\tab --> con: <=1    disc: >=3  \\cr\n#' 1 2 3 4 5 6          \\tab --> con: <=1    disc: >=3  \\cr\n#' 1 2 3 4 5 6 7        \\tab --> con: <=1    disc: >=4  \\cr\n#' 1 2 3 4 5 6 7 8      \\tab --> con: <=1    disc: >=5  \\cr\n#' 1 2 3 4 5 6 7 8 9    \\tab --> con: <=2    disc: >=5  \\cr\n#' 1 2 3 4 5 6 7 8 9 10 \\tab --> con: <=2    disc: >=6  \\cr\n#' }\n#' \n#' \\bold{Defining the correlations} \\cr\n#' As the implications between constructs cannot be derived from a \n#' rating grid directly, the correlation between two constructs \n#' is used as an indicator for implication. A large correlation means\n#' that one construct pole implies the other. A small correlation \n#' indicates a lack of implication. The minimum criterion for a correlation\n#' to indicate implication is set to .35 (cf. Feixas & Saul, 2004).\n#' The user may also chose another value. To get a an impression\n#' of the distribution of correlations in the grid, a visualization can \n#' be prompted via the argument \\code{show}.\n#' When calculating the correlation used to assess if an implication\n#' is given or not, the elements under consideration (i. e. self and ideal self)\n#' can be included (default) or excluded. The options will cause different\n#' correlations (see argument \\code{exclude}). \\cr \\cr\n#'\n#' \\bold{Example of an implicative dilemma} \\cr\n#' A depressive person considers herself as timid and \n#' wished to change to the opposite pole she defines as extraverted. \n#' This construct is called discrepant as the construction of the 'self'\n#' and the desired state (e.g. described by the 'ideal self') on \n#' this construct differ. The person also considers herself as \n#' sensitive (preferred pole) for which the opposite pole is selfish. \n#' This construct is congruent, as the person construes herself as \n#' she would like to be. If the person now changed on the discrepant \n#' construct from the undesired to the desired pole, i.e. from timid \n#' to extraverted, the question can be asked what consequences such a \n#' change has. If the person construes being timid and being sensitive \n#' as related and that someone who is extraverted will not be timid, a \n#' change on the first construct will imply a change on the congruent \n#' construct as well. Hence, the positive shift from timid to extraverted\n#' is presumed to have a undesired effect in moving from sensitive towards\n#' selflish. This relation is called an implicative dilemma. As the \n#' implications of change on a construct cannot be derived from a rating \n#' grid directly, the correlation between two constructs is used as an \n#' indicator for implication.\n#'\n#'\n#' @title                 Detect implicative dilemmas (conflicts).\n#'\n#' @param x               \\code{repgrid} object.\n#' @param self            Numeric. Index of self element.\n#' @param ideal           Numeric. Index of ideal self element. \n#' @param diff.mode       Numeric. Mode to classify construct pairs into congruent and\n#'                        discrepant. \\code{diff.mode=1} will use the difference in \n#'                        ratings between the self and the ideal element to determine if\n#'                        the construct is congruent or discrepant. No other\n#'                        modes have yet been implemented.\n#' @param diff.congruent  Is used if \\code{diff.mode=1}. Maximal difference between\n#'                        element ratings to define construct as congruent (default\n#'                        \\code{diff.congruent=1}). Note that the value\n#'                        needs to be adjusted by the user according to the rating scale\n#'                        used.\n#' @param diff.discrepant Is used if \\code{diff.mode=1}. Minimal difference between\n#'                        element ratings to define construct as discrepant (default\n#'                        \\code{diff.discrepant=3}). Note that the value\n#'                        needs to be adjusted by the user according to the rating scale\n#'                        used.\n#' @param diff.poles      Not yet implemented.\n#' @param r.min           Minimal correlation to determine implications between\n#'                        constructs.\n#' @param exclude         Whether to exclude the elements self and ideal self \n#'                        during the calculation of the inter-construct correlations.\n#'                        (default is \\code{FALSE}).\n#' @param output          The type of output printed to the console. \\code{output=1} prints\n#'                        classification of the construct into congruent and discrepant\n#'                        and the detected dilemmas. \\code{output=1} only prints the latter.\n#'                        \\code{output=0} will surpress printing.\n#'                        Note that the type of output does not affect the object\n#'                        that is returned invisibly which will be the same in any case\n#'                        (see value).\n#' @param show            Whether to additionally plot the distribution\n#'                        of correlations to help the user assess what level\n#'                        is adequate for \\code{r.min}.\n#' @param index           Whether to print index numbers in front of each construct \n#'                        (default is \\code{TRUE}).\n#' @param trim            The number of characters a construct (element) is trimmed to (default is\n#'                        \\code{20}). If \\code{NA} no trimming is done. Trimming\n#'                        simply saves space when displaying the output.\n#' @param digits          Numeric. Number of digits to round to (default is \n#'                        \\code{2}).\n#'\n#' @author                Mark Heckmann\n#' @export\n#' @return                Called for console output. Invisbly returns a list containing\n#'                        the result dataframes and all results from the calculations.\n#' @references            \n#'                        Bell, R. C. (2009). \\emph{Gridstat version 5 - A Program for Analyzing\n#'                        the Data of A Repertory Grid} (manual). University of Melbourne,\n#'                        Australia: Department of Psychology.\n#'                        \n#'                        Dorough, S., Grice, J. W., & Parker, J. (2007). Implicative \n#'                        dilemmas and psychological well-being. \\emph{Personal Construct\n#'                        Theory & Practice}, (4), 83-101.\n#'\n#'                        Feixas, G., & Saul, L. A. (2004). The Multi-Center Dilemma \n#'                        Project: an investigation on the role of cognitive conflicts \n#'                        in health. \\emph{The Spanish Journal of Psychology, 7}(1), 69-78.\n#'\n#'                        Feixas, G., Saul, L. A., & Sanchez, V. (2000). Detection and \n#'                        analysis of implicative dilemmas: implications for the therapeutic\n#'                        process. In J. W. Scheer (Ed.), \\emph{The Person in Society: \n#'                        Challenges to a Constructivist Theory}. Giessen: Psychosozial-Verlag.\n#'\n#'                        Winter, D. A. (1982). Construct relationships, psychological\n#'                        disorder and therapeutic change. \\emph{British Journal of Medical \n#'                        Psychology, 55} (Pt 3), 257-269.\n#'\n#' @examples \\dontrun{\n#'  \n#'  indexDilemma(boeker, self=1, ideal=2)\n#'  indexDilemma(boeker, self=1, ideal=2, out=2)\n#'\n#'  # additionally show correlation distribution\n#'  indexDilemma(boeker, self=1, ideal=2, show=T)\n#'\n#'  # adjust minimal correlation\n#'  indexDilemma(boeker, 1, 2, r.min=.25)\n#'\n#'  # adjust congruence and discrepance ranges\n#'  indexDilemma(boeker, 1, 2, diff.con=0, diff.disc=4)\n#'\n#'  }\n#'\nindexDilemma <- function(x, self, ideal, \n                         diff.mode = 1, diff.congruent = NA,\n                         diff.discrepant = NA, diff.poles=1, \n                         r.min=.35, exclude=FALSE, digits=2, show=F,\n                         output=1, \n                         index=T, trim=20)\n{\n  if (missing(self) | missing(ideal))\n    stop(\"you must specify which which elements are the 'self' and the 'ideal self'\")\n  \n  # automatic selection of a priori criteria\n  sc <- getScale(x)\n  if (is.na(diff.congruent))\n    diff.congruent <- floor(diff(sc) * .25)\n  if (is.na(diff.discrepant))\n    diff.discrepant <-  ceiling(diff(sc) * .6)\n  \n  # detect dilemmas\n  res <- indexDilemmaInternal(x, self=self, ideal=ideal, \n                              diff.mode=diff.mode, diff.congruent=diff.congruent,\n                              diff.discrepant=diff.discrepant, diff.poles=diff.poles,\n                              r.min=r.min, exclude=exclude, digits=digits, \n                              index=index, trim=trim)\n  \n  # type of output printed to te console\n  enames <- getElementNames2(x, trim=trim, index=T)\n  \n  if (output == 1){\n    indexDilemmaOut0(res, self, ideal, enames, \n                     diff.discrepant, diff.congruent, \n                     exclude, r.min)\n    indexDilemmaOut1(res)\n    indexDilemmaOut2(res, exclude)\n  } else if(output == 2){\n    indexDilemmaOut0(res, self, ideal, enames, \n                     diff.discrepant, diff.congruent, \n                     exclude, r.min)\n    indexDilemmaOut2(res, exclude)\n  } \n  # show distribution if prompted\n  if (show)\n    indexDilemmaShowCorrelationDistribution(x, self, ideal)\n  invisible(res)\n}\n\n\n\n######################\n# Pemutation test to test if grid is random.\n# \"The null hypothesis [is] that a particular grid \n# is indis- tinguishable from an array of random numbers\" \n# (Slater, 1976, p. 129).\n#\nrandomTest <- function(x){\n  x\n}\n# permutationTest\n# Hartmann 1992: \n# To illustrate: If a person decided to produce a nonsense grid, \n# the most appropriate way to achieve this goal would be to rate \n#(rank) the elements randomly. The variation of the elements on \n# the con- structs would lack any psychological sense. Every \n# statistical analysis should then lead to noninterpretable results.\n\n\n\n\n\n\n\n",
    "created" : 1400053353814.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3710122736",
    "id" : "B462C6D6",
    "lastKnownWriteTime" : 1400053423,
    "path" : "~/_mh/programming/R/pkg_dev/grid/OpenRepGrid/OpenRepGrid/R/measures.r",
    "project_path" : "R/measures.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}