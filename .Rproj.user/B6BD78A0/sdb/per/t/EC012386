{
    "contents" : "\n###############################################################################\n\n\n#' Calculate coordinates for biplot.\n#'\n#' @param x             \\code{repgrid} object.\n#' @param g             Power of the singular value matrix assigned to the left singular \n#'                      vectors, i.e. the constructs.\n#' @param h             Power of the singular value matrix assigned to the right singular \n#'                      vectors, i.e. the elements.\n#' @param col.active    Columns (elements) that are no supplementary points, i.e. they are used\n#'                      in the SVD to find principal components. default is to use all elements.\n#' @param col.passive   Columns (elements) that are supplementary points, i.e. they are NOT used\n#'                      in the SVD but projecte into the component space afterwards. They do not \n#'                      determine the solution. Default is \\code{NA}, i.e. no elements are set \n#'                      supplementary.\n#' @param ...           Parameters to be passed on to \\code{center()} and \\code{normalize}.       \n#' @return              a \\code{list}.\n#'\n#' @author        Mark Heckmann\n#' @keywords internal\n#' @export\n#' \ncalcBiplotCoords <- function(x, g=0, h=1-g, \n                             col.active=NA, \n                             col.passive=NA, \n                             ... ){\n  # definition of active and passive (supplementary points) \n  if (!identical(col.active, NA) & !identical(col.passive, NA))\n    stop(\"active OR passive columns must be defined\")\n  ne <- getNoOfElements(x)\n  if (identical(col.active, NA)){                   # if no active points defined\n    col.active <- seq_len(ne)                       # the rest is set active\n    col.active <- setdiff(col.active, col.passive)\n  } else if (identical(col.passive, NA)){           # if no passive points defined\n    col.passive <- seq_len(ne)                      # the is set passive\n    col.passive <- setdiff(col.passive, col.active)\n  }\n  \n  X <- center(x, ...)           # center grid\n  X <- normalize(X, ...)        # normalize grid\n  \n  X.active <- X[ , col.active]  # X with active columns (elements) only. Used for SVD. \n                                # The other supplementary elements are projected afterwards.\n\n  dec <- svd(X.active)    # make SVD for reduced set of active points\n  U <- dec$u              # left singular vector matrix\n  D <- dec$d              # matrix of singular values\n  V <- dec$v              # right singular vector matrix      \n  \n  # constructs coords\n  C <- U %*% diag(D^g)    # standard form       \n  # C <- X[, col.active] %*% V %*% (D^h)^-1 \n  # C <- X[, col.active] %*% V %*% (D^(1-g))^-1 \n  \n  # element coords\n  # E <- V %*% diag(D^h)                  # not used as supplementary points need to be calculated\n  # t(X) %*% U %*% (D^g)^-1               # only works when g + h =1, thus: \n  E <- t(X) %*% U %*% diag((D^(1-h))^-1)  # only dependent on h not g                                            \n\n  rownames(C) <- getConstructNames(x)[ ,2]  # names of direction into which vector points\n  rownames(E) <- getElementNames(x)\n    \n  x@calcs$biplot <- list(X=X, element.coords=E, construct.coords=C,\n                         D=D,U=U, V=V, col.passive=col.active, \n                         col.passive=col.passive)\n  x\n}\n\n\n#' Map arbitrary numeric vector to a given range of values. \n#'\n#' From a given numeric vector \\code{z} the range is determined and \n#' the values are linearly mapped onto the interval \n#' given by \\code{val.range}. This \n#' funtion can be used in order to map arbitrary vectors to a given\n#' range of values.\n#'\n#' @param  z          numeric vector.\n#' @param  val.range  numeric vector of lengths two (default \\code{c(.5, 1)}).\n#' @return numeric vector\n#'\n#' @author  Mark Heckmann\n#' @keywords internal\n#' @export\n#'\nmapCoordinatesToValue <- function(z, val.range=c(.5, 1)) {\n\tz.range <- c(min(z, na.rm=T), max(z, na.rm=T))\n\tslope <-  diff(val.range) / diff(z.range)\n\tint <- val.range[1] - z.range[1] * slope\n\tvals <- int + slope * z\n  round(vals, 10)   # round at 10th digit to prevent values like 1.00000000001\n}\n\n\n#' Determine color values according to a given range of values. \n#'\n#' From a given numeric vector z the range is determined and the values are \n#' linearly mapped onto the interval given by \\code{val.range}. Then \n#' a color ramp using the colors given by \\code{color} is created and \n#' the mapped values are transformed into hex color values. \n#'\n#' @param  z          numeric vector.\n#' @param  color      vector of length two giving color values \\code{c(\"white\", \"black\")}.\n#' @param  val.range  numeric vector of lengths two (default \\code{c(.2, .8)}).\n#' @return numeric vector\n#'\n#' @author  Mark Heckmann\n#' @keywords internal\n#' @export\n#'\nmapCoordinatesToColor <- function(z, colors=c(\"white\", \"black\"), val.range=c(.2,.8)){\n  colorRamp <- makeStandardRangeColorRamp(colors)\n  vals <- mapCoordinatesToValue(z, val.range)\n  colorRamp(unlist(vals))     # unlist in case z comes as a data frame column\n}\n\n\n#' Coordinates of a sourrounding rectangle in direction of a given vector. \n#'\n#' An arbitrary numeric vector in 2D is to be extented so it will \n#' end on the borders of a sourrounding rectangle of a given size.\n#' Currently the vector is supposed to start in the origin \\code{c(0,0)}.\n#'\n#' @param x      numeric vector of x coordinates x coordinates. \n#' @param y      numeric vector of y coordinates x coordinates. \n#' @param xmax   maximal x value for sourrounding rectangle (default is \\code{1}).\n#' @param ymax   maximal y value for sourrounding rectangle (default is \\code{1}).\n#' @param cx     center of retangle in x direction (not yet supported).\n#' @param cy     center of retangle in x direction (not yet supported).\n#' \n#' @return       a \\code{dataframe} containing the x and y coordinates for the \n#'               extended vectors.\n#'\n#' @author    Mark Heckmann\n#' @keywords internal\n#' @export\n#'\n#' @examples \\dontrun{\n#'   calcCoordsBorders(1:10, 10:1)\n#' \n#'   x <- c(-100:0, 0:100, 100:0, 0:-100)/10\n#'   y <- c(0:100, 100:0, -(0:100), -(100:0))/10\n#'   xy1 <- calcCoordsBorders(x, y)\n#'   xy2 <- calcCoordsBorders(x, y, xm=1.2, ym=1.2)\n#'   plot(xy2[,1], xy2[,2], type=\"n\")\n#'   segments(xy1[,1],xy1[,2],xy2[,1], xy2[,2])\n#' }\n#'\ncalcCoordsBorders <- function(x, y, xmax=1, ymax=1, cx=0, cy=0)\n{\n  is.lr.part <- abs(x*ymax/xmax) >= abs(y)        # which are left and right parts\n\n  # left and right part             \n  sign.x <- sign(x)             # positive or negative value    \n  sign.x[sign.x == 0] <- 1      # zeros in posistive direction\n  a.lr <- xmax * sign(x)        # x is fix on the left and right side\n  b.lr <- y/x * a.lr            \n  \n  # upper and lower part\n  sign.y <- sign(y)\n  sign.y[sign.y == 0] <- 1\n  b.ul <- ymax * sign(y)\n  a.ul <- x/y * b.ul\n  \n  a.lr <- unlist(a.lr)\n  b.lr <- unlist(b.lr)\n  a.ul <- unlist(a.ul)\n  b.ul <- unlist(b.ul)\n  \n  a.lr[is.nan(a.lr)] <- 0       # in case one of x or y is zero Inf results ans subsequently NaN\n  b.lr[is.nan(b.lr)] <- 0\n  a.ul[is.nan(a.ul)] <- 0\n  b.ul[is.nan(b.ul)] <- 0  \n  \n  # join both parts\n  b <- (b.ul * !is.lr.part) + (b.lr * is.lr.part)\n  a <- (a.ul * !is.lr.part) + (a.lr * is.lr.part)\n  a[abs(a) > xmax] <- (xmax * sign(a))[abs(a) > xmax]\n  b[abs(b) > ymax] <- (ymax * sign(b))[abs(b) > ymax]\n  \n  data.frame(x=a, y=b)\n}\n\n\n# calculate the coords for the label rectangle\n#\n# TODO: supply x.ext in mm and convert to usr coords\n#\n# @param  xy        \\code{dataframe} with x and y coords.\n# @param  labels    vector of strings.\n# @param  cex       vector of cex values (default is \\code{.7}).\n# @param  x.ext     scalar giving the horizontal margin \n#                   of the rectangle in NDC coordinates\n#                   (default is \\code{.02}).\n# @param  y.ext     scalar giving the vertical margin \n#                   of the rectangle in NDC coordinates\n#                   (default is \\code{.02}).\n# @return \\code{dataframe} with coordinates for the lower left and \n#         upper right rectangle borders (\\code{x0, y0, x1, y1}).\n#\ncalcRectanglesCoordsForLabels <- function(xy, labels, cex=.7, \n                                          x.ext=.02, y.ext=.02){\n  if (length(cex) == 1)\n    cex <- rep(cex, dim(xy)[1])\n  \n  heights <- vector()\n  widths <- vector()\n  \n  for (i in 1:dim(xy)[1]){\n    heights[i] <- strheight(labels[i], cex=cex[i])   # determine necessary height for text \n    widths[i] <- strwidth(labels[i], cex=cex[i])     # determine necessary width for text \n  }\n  # make adj adjustements\n  leftSide <- xy[, 1] < 0\n  labelsBorders <- data.frame(x0= xy[, 1] - (widths * leftSide), \n                              y0= xy[, 2] - heights/2, \n                              x1= xy[, 1] + (widths * !leftSide), \n                              y1= xy[, 2] + heights/2)\n  # extend borders for neater look\n  labelsBorders$x0 <- labelsBorders$x0 - x.ext\n  labelsBorders$y0 <- labelsBorders$y0 - y.ext\n  labelsBorders$x1 <- labelsBorders$x1 + x.ext\n  labelsBorders$y1 <- labelsBorders$y1 + y.ext\n  \n  labelsBorders\n}\n\n\n#' Detect if two rectangles overlap. \n#'\n#' The overlap is assessed in x AND y.\n#'\n#' @param  a   vector with four coordinates \\code{c(x0,y0,x1,y1)}.\n#' @param  b   vector with four coordinates \\code{c(x0,y0,x1,y1)}.\n#' @return     \\code{logical}. TRUE if rectangles overlap.\n#'\n#' @keywords internal\n#' @export\n#'\n#' @examples \\dontrun{\n#'   #overlap in x and y\n#'   a <- c(0,0,2,2)\n#'   b <- c(1,1,4,3)\n#'   plot(c(a,b), c(a,b), type=\"n\")\n#'   rect(a[1], a[2], a[3], a[4])\n#'   rect(b[1], b[2], b[3], b[4])\n#'   doRectanglesOverlap(a,b)\n#' \n#'   # b contained in a vertically\n#'   a <- c(5,0,20,20)\n#'   b <- c(0, 5,15,15)\n#'   plot(c(a,b), c(a,b), type=\"n\")\n#'   rect(a[1], a[2], a[3], a[4])\n#'   rect(b[1], b[2], b[3], b[4])\n#'   doRectanglesOverlap(a,b)\n#' \n#'   # overlap only in y\n#'   a <- c(0,0,2,2)\n#'   b <- c(2.1,1,4,3)\n#'   plot(c(a,b), c(a,b), type=\"n\")\n#'   rect(a[1], a[2], a[3], a[4])\n#'   rect(b[1], b[2], b[3], b[4])\n#'   doRectanglesOverlap(a,b)\n#' }\n#'\ndoRectanglesOverlap <- function(a, b, margin=0){\n  overlap1D <- function(a0, a1, b0, b1){ # overlap if one of four conditions is satisfied\n    (a0 <= b1 & b1 <= a1) |     # b overlaps at bottom\n    (a0 <= b0 & b0 <= a1) |     # b overlaps at top\n    (a0 >= b0 & a1 <= b1) |     # b overlaps at bottom and top\n    (a0 <= b0 & a1 >= b1)       # b contained within a\n  }\n  overlap.x <- overlap1D(a[1], a[3], b[1], b[3])  # overlap in x ?\n  overlap.y <- overlap1D(a[2], a[4], b[2], b[4])  # overlap in y ?\n  as.logical(overlap.x & overlap.y)               # overlap in x and y, strip off vector names ?\n}\n\n\n# calculate angle between vector and x-y plane\n# a   vector\n# n   plane normal vector\ndegreesBetweenVectorAndPlane <- function(a, n){\n    rad <- asin( abs(n %*% a) / \n                (sum(n^2)^.5 * sum(a^2)^.5))\n    rad * 180/pi                # convert from radians to degrees\n}\n\n\n#' A graphically unsophisticated version of a biplot.\n#'\n#' It will draw elements and constructs vectors using similar\n#' arguments as \\code{\\link{biplot2d}}. It is a version for quick \n#' exploration used during development.\n#' \n#' @param x             \\code{repgrid} object.\n#' @param dim           Dimensions (i.e. principal components) to be used for biplot \n#'                      (default is \\code{c(1,2)}).\n#' @param  center\t\t    Numeric. The type of centering to be performed. \n#'                      0= no centering, 1= row mean centering (construct), \n#'                      2= column mean centering (elements), 3= double-centering (construct and element means),\n#'                      4= midpoint centering of rows (constructs).\n#'                      The default is \\code{1} (row centering).\n#' @param normalize     A numeric value indicating along what direction (rows, columns)\n#'                      to normalize by standard deviations. \\code{0 = none, 1= rows, 2 = columns}\n#'                      (default is \\code{0}).\n#' @param g             Power of the singular value matrix assigned to the left singular \n#'                      vectors, i.e. the constructs.\n#' @param h             Power of the singular value matrix assigned to the right singular \n#'                      vectors, i.e. the elements.\n#' @param col.active    Columns (elements) that are no supplementary points, i.e. they are used\n#'                      in the SVD to find principal components. default is to use all elements.\n#' @param col.passive   Columns (elements) that are supplementary points, i.e. they are NOT used\n#'                      in the SVD but projecte into the component space afterwards. They do not \n#'                      determine the solution. Default is \\code{NA}, i.e. no elements are set \n#'                      supplementary.\n#' @param unity         Scale elements and constructs coordinates to unit scale in 2D (maximum of 1)\n#'                      so they are printed more neatly (default \\code{TRUE}).\n#' @param zoom          Scaling factor for all vectors. Can be used to zoom\n#'                      the plot in and out (default \\code{1}).\n#' @param scale.e       Scaling factor for element vectors. Will cause element points to move a bit more\n#'                      to the center. This argument is for visual appeal only.\n#' @param e.point.col   Color of the element symbols (default is \\code{\"black\"}.\n#' @param e.point.cex   Size of the element symbol (default is \\code{1}.\n#' @param e.label.col   Color of the element labels (default is \\code{\"black\"}.\n#' @param e.label.cex   Size of the element labels (default is \\code{.7}.\n#' @param c.point.col   Color of the construct lines (default is \\code{grey(.6)}.\n#' @param c.label.col   Color of the construct labels (default is \\code{grey(.6)}.\n#' @param c.label.cex   Size of the costruct labels (default is \\code{.6}.\n#' @param ...           Parameters to be passed on to \\code{center()} and \\code{normalize}.       \n#' @return              \\code{repgrid} object.\n#'\n#' @author Mark Heckmann\n#' @export\n#' \n#' @seealso   Unsophisticated biplot: \\code{\\link{biplotSimple}}; \\cr\n#'            2D biplots:\n#'            \\code{\\link{biplot2d}},\n#'            \\code{\\link{biplotEsa2d}},\n#'            \\code{\\link{biplotSlater2d}};\\cr\n#'            Pseudo 3D biplots:\n#'            \\code{\\link{biplotPseudo3d}},  \n#'            \\code{\\link{biplotEsaPseudo3d}},\n#'            \\code{\\link{biplotSlaterPseudo3d}};\\cr\n#'            Interactive 3D biplots:\n#'            \\code{\\link{biplot3d}},\n#'            \\code{\\link{biplotEsa3d}},\n#'            \\code{\\link{biplotSlater3d}};\\cr\n#'            Function to set view in 3D:\n#'            \\code{\\link{home}}.\n#'\n#' @examples \\dontrun{\n#'    \n#'    biplotSimple(boeker)\n#'    biplotSimple(boeker, unity=F)\n#'\n#'    biplotSimple(boeker, g=1, h=1)              # INGRID biplot\n#'    biplotSimple(boeker, g=1, h=1, center=4)    # ESA biplot\n#'\n#'    biplotSimple(boeker, zoom=.9)               # zooming out\n#'    biplotSimple(boeker, scale.e=.6)            # scale element vectors\n#'\n#'    biplotSimple(boeker, e.point.col=\"brown\")   # change colors\n#'    biplotSimple(boeker, e.point.col=\"brown\",\n#'                 c.label.col=\"darkblue\")\n#' }\n#'\nbiplotSimple <- function(x, dim=1:2, center=1, normalize=0, \n                          g=0, h=1-g, unity=T,\n                          col.active=NA, \n                          col.passive=NA, \n                          scale.e=.9, zoom=1, \n                          e.point.col=\"black\", \n                          e.point.cex=1,\n                          e.label.col=\"black\",\n                          e.label.cex=.7, \n                          c.point.col=grey(.6),\n                          c.label.col=grey(.6),\n                          c.label.cex=.6,\n                          ...){\n  par(mar=c(1,1,1,1))\n  d1 <- dim[1]\n  d2 <- dim[2]\n  \n  x <- calcBiplotCoords(x, g=g, h=h, center=center, \n                        normalize=normalize, \n                        col.active=col.active, \n                        col.passive=col.passive, ...)\n  cnames <- getConstructNames(x)\n  E <- x@calcs$biplot$el\n  C <- x@calcs$biplot$con\n  X <- x@calcs$biplot$X\n\n  max.e <- max(abs(E[ ,dim]))\n  max.c <- max(abs(C[ ,dim]))\n  mv <- max(max.e, max.c)\n  if (unity){\n    max.e <- max(apply(E[ ,dim[1:2]]^2, 1, sum)^.5)   # maximal length of element vectors\n    max.c <- max(apply(C[ ,dim[1:2]]^2, 1, sum)^.5)   # maximal length of construct vectors\n    se <- 1/max.e  * scale.e   # scale to unity to make E and C same size\n    sc <- 1/max.c\n  } else {\n    se <- 1\n    sc <- 1\n  }\n  Cu <- C * sc\n  Eu <- E * se\n  \n  mv <- max(abs(rbind(Cu, Eu)))\n  Cu <- Cu * zoom\n  Eu <- Eu * zoom\n  \n  # make biplot\n  plot(0, xlim=c(-mv, mv), ylim=c(-mv, mv), type=\"n\", asp=1,\n        xaxt=\"n\", yaxt=\"n\", xaxs=\"i\", yaxs=\"i\")\n  abline(v=0, h=0, col=\"grey\")\n  \n  # plot constructs and labels\n  arrows(0,0, -Cu[ ,d1], -Cu[ ,d2], length=.05, \n         col=c.point.col, lty=1)              # plot left poles\n  text(-Cu[ ,d1], -Cu[ ,d2], cnames[,1], pos=1, \n        cex=c.label.cex, col=c.label.col)\n  arrows(0,0, Cu[ ,d1], Cu[ ,d2], length=.05, \n         col=c.point.col, lty=3)               # plot right poles\n  text(Cu[ ,d1], Cu[ ,d2], cnames[,2], pos=1, \n       cex=c.label.cex, col=c.label.col)\n  \n  # plot elements and labels\n  points(Eu[, dim], pch=15, col=e.point.col, cex=e.point.cex)           # plot elements\n  text(Eu[, dim], labels=rownames(Eu), cex=e.label.cex,\n        col=e.label.col, pos=2)                                      # label elements  \n  invisible(x)\n}\n\n# library(xtable)\n# x <- biplotSimple(raeithel, dim=1:2, g=1, h=1, col.act=c(1,2,3,5,10,12))\n# ssq.table <- ssq(x)\n# #ssq.table[ssq.table < 10] <- NA\n# res <- xtable(round(ssq.table, 1), digits=1, \n#               align=c(\"l\", rep(\"r\", ncol(ssq.table))), caption=\"Percentage of element's SSQ explained\")\n# print(res, table.placement=\"H\", hline.after=c(-1,0,nrow(ssq.table)-1, nrow(ssq.table)))\n\n\n\n#' Prepare dataframe passed to drawing functions for biplots.\n#'\n#' Data frame contains the variables \\code{type, show, x, y, \n#'  z, labels, color, cex}.\n#'\n#' @param x             \\code{repgrid} object.\n#' @param dim           Dimensions to be used for biplot (default is \\code{c(1,2)}).\n#' @param map.dim       Third dimension used to map aesthetic attributes (depth)\n#'                      (default is \\code{3}).\n#' @param e.point.col   Color(s) of the element symbols. Two values can be entered that will\n#'                      create a color ramp. The values of \\code{map.dim} are mapped onto the ramp.\n#'                      The default is \\code{c(\"white\", \"black\")}. If only one color color value\n#'                      is supplied (e.g. \\code{\"black\"}) no mapping occurs and all elements\n#'                      will have the same color irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param e.point.cex   Size of the element symbols. Two values can be entered that will\n#'                      represents the lower and upper size of a range of cex the values of \\code{map.dim} \n#'                      are mapped onto. The default is \\code{c(.4, .8)}. If only one cex value\n#'                      is supplied (e.g. \\code{.7}) no mapping occurs and all elements\n#'                      will have the same size irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param e.label.col   Color(s) of the element labels. Two values can be entered that will\n#'                      create a color ramp. The values of \\code{map.dim} are mapped onto the ramp.\n#'                      The default is \\code{c(\"white\", \"black\")}. If only one color color value\n#'                      is supplied (e.g. \\code{\"black\"}) no mapping occurs and all element labels\n#'                      will have the same color irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param e.label.cex   Size of the element labels. Two values can be entered that will\n#'                      represents the lower and upper size of a range of cex the values of \\code{map.dim} \n#'                      are mapped onto. The default is \\code{c(.4, .8)}. If only one cex value\n#'                      is supplied (e.g. \\code{.7}) no mapping occurs and all element labels\n#'                      will have the same size irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param e.color.map   Value range to determine what range of the color ramp defined in \n#'                      \\code{e.color} will be used for mapping the colors. \n#'                      Default is \\code{c(.4, ,1)}. Usually not important for the user. \n#' @param c.point.col   Color(s) of the construct symbols. Two values can be entered that will\n#'                      create a color ramp. The values of \\code{map.dim} are mapped onto the ramp.\n#'                      The default is \\code{c(\"white\", \"darkred\")}. If only one color color value\n#'                      is supplied (e.g. \\code{\"black\"}) no mapping occurs and all elements\n#'                      will have the same color irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param c.point.cex   Size of the construct symbols. Two values can be entered that will\n#'                      represents the lower and upper size of a range of cex the values of \\code{map.dim} \n#'                      are mapped onto. The default is \\code{c(.4, .8)}. If only one cex value\n#'                      is supplied (e.g. \\code{.7}) no mapping occurs and all elements\n#'                      will have the same size irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param c.label.col   Color(s) of the construct labels. Two values can be entered that will\n#'                      create a color ramp. The values of \\code{map.dim} are mapped onto the ramp.\n#'                      The default is \\code{c(\"white\", \"black\")}. If only one color color value\n#'                      is supplied (e.g. \\code{\"black\"}) no mapping occurs and all construct labels\n#'                      will have the same color irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param c.label.cex   Size of the construct labels. Two values can be entered that will\n#'                      represents the lower and upper size of a range of cex the values of \\code{map.dim} \n#'                      are mapped onto. The default is \\code{c(.4, .8)}. If only one cex value\n#'                      is supplied (e.g. \\code{.7}) no mapping occurs and all construct labels\n#'                      will have the same size irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param c.color.map   Value range to determine what range of the color ramp defined in \n#'                      \\code{c.color} will be used for mapping. Default is \\code{c(.4, ,1)}.\n#'                      Usually not important for the user. \n#' @param devangle      The deviation angle from the x-y plane in degrees. These can only be calculated\n#'                      if a third dimension \\code{map.dim} is specified. Only the constructs \n#'                      vectors that do not depart \n#'                      more than the specified degrees from the shown x-y plane will be printed.\n#'                      This facilitates the visual interpretation, as only vectors represented in\n#'                      the current plane are shown. Set the value to \\code{91} (default) \n#'                      to show all vectors.\n#' @param unity         Scale elements and constructs coordinates to unit scale in 2D (maximum of 1)\n#'                      so they are printed more neatly (default \\code{TRUE}).\n#' @param unity3d       Scale elements and constructs coordinates to unit scale in 3D (maximum of 1)\n#'                      so they are printed more neatly (default \\code{TRUE}).\n#' @param scale.e       Scaling factor for element vectors. Will cause element points to move a bit more\n#'                      to the center. This argument is for visual appeal only.\n#' @param ...           Not evaluated. \n#'\n#' @return              \\code{dataframe} containing the variables \\code{type, show, x, y, \n#'                      z, labels, color, cex}. Usually not of interest to the user.\n#' @note                TODO:  How to omit \\code{map.dim}?\n#'\n#' @author  Mark Heckmann\n#' @keywords internal\n#' @export\n#'\nprepareBiplotData <- function(x, dim=c(1,2), map.dim=3, \n                               #e.color=c(\"white\", \"black\"), \n                               #c.color=c(\"white\", \"darkred\"),\n                               e.label.cex=.8,\n                               c.label.cex=.6,\n                               e.label.col=\"black\",\n                               c.label.col=grey(.8),\n                               e.point.cex=.7,\n                               c.point.cex=.8,\n                               e.point.col=\"black\",\n                               c.point.col=\"darkred\",\n                               #e.cex.map=c(.6, .8),\n                               #c.cex.map=c(.6, .8),\n                               e.color.map=c(.4, 1),\n                               c.color.map=c(.4, 1),\n                               c.points.devangle=90,\n                               c.labels.devangle=90,\n                               c.points.show=TRUE,\n                               c.labels.show=TRUE,\n                               e.points.show=TRUE,\n                               e.labels.show=TRUE, \n                               unity=TRUE, \n                               unity3d=FALSE, \n                               scale.e=.9, \n                               ...)\n{\n  dim <- c(dim, map.dim)\n\n  # make vector of length two if only one color/cex is specified\n  #if (length(e.color) == 1)         # element color\n  #  e.color <- rep(e.color, 2)          \n  #if (length(c.color) == 1)         # construct color\n  #  c.color <- rep(c.color, 2)\n  #if (length(e.cex.map) == 1)       # element cex for pseudo 3d dimension\n  #  e.cex.map <- rep(e.cex.map, 2)\n  #if (length(c.cex.map) == 1)       # construct cex for pseudo 3d dimension\n  #  c.cex.map <- rep(c.cex.map, 2)\n  \n  if (length(e.label.col) == 1)     # label color(s) for elements \n    e.label.col <- rep(e.label.col, 2)\n  if (length(c.label.col) == 1)     # label color(s) for constructs \n    c.label.col <- rep(c.label.col, 2)  \n  if (length(e.point.col) == 1)     # point color(s) for elements \n    e.point.col <- rep(e.point.col, 2)\n  if (length(c.point.col) == 1)     # point color(s) for constructs \n    c.point.col <- rep(c.point.col, 2)\n  \n  if (length(e.label.cex) == 1)     # label cex(s) for elements \n    e.label.cex <- rep(e.label.cex, 2)\n  if (length(c.label.cex) == 1)     # label cex(s) for constructs \n    c.label.cex <- rep(c.label.cex, 2)  \n  if (length(e.point.cex) == 1)     # point cex(s) for elements \n    e.point.cex <- rep(e.point.cex, 2)\n  if (length(c.point.cex) == 1)     # point cex(s) for constructs \n    c.point.cex <- rep(c.point.cex, 2)\n  \n    if (length(e.color.map) == 1)     # element color for pseudo 3d dimension\n      e.color.map <- rep(e.color.map, 2)\n    if (length(c.color.map) == 1)     # construct color for pseudo 3d dimension\n      c.color.map <- rep(c.color.map, 2)\n      \n  # construct data frame containing all information needed for different plotting functions\n  # (e.g. rgl and biplot functions)\n  labels.e <- getElementNames(x)\n  labels.cl <- getConstructNames(x)[,1] \n  labels.cr <- getConstructNames(x)[,2]\n  labels.all <- c(labels.e, labels.cr, labels.cl)         # join all labels\n  type <- factor(c(rep(\"e\", getNoOfElements(x)),          # make factor specifying if row is element or construct\n                   rep(c(\"cl\", \"cr\"), each=getNoOfConstructs(x))))\n  df <- data.frame(type=type, label=labels.all, stringsAsFactors=FALSE)\n  df$cex <- .7            # default cex\n  df$showpoint <- T       # default value for show point\n  df$showlabel <- T       # default value for show label\n  df$color <- grey(0)     # default color\n  df$label.col <- \"darkgreen\"     # default label color\n  df$point.col <- \"purple\"    # default point color\n  df$label.cex <- .7          # default label size\n  df$point.cex <- .7          # default point size\n  \n  # calculate and add coordinates\n  #x <- calcBiplotCoords(x, ...)\n   \n  E <- x@calcs$biplot$el\n  C <- x@calcs$biplot$con\n  X <- x@calcs$biplot$X\n\n  # scale to unity to make E and C same size.\n  # Two types of unity, for 2D and 3D\n  \n  if (unity){\n    max.e <- max(apply(E[ ,dim[1:2]]^2, 1, sum)^.5)   # maximal length of element vectors\n    max.c <- max(apply(C[ ,dim[1:2]]^2, 1, sum)^.5)   # maximal length of construct vectors\n    se <- 1/max.e  * scale.e   # scale to unity to make E and C same size\n    sc <- 1/max.c   \n  } \n  if (unity3d){\n    #max.e <- max(abs(E[ ,dim[1:3]]), na.rm=T)    \n    #max.c <- max(abs(C[ ,dim[1:3]]), na.rm=T)    \n    max.e <- max(apply(E[ ,dim[1:3]]^2, 1, sum)^.5)   # maximal length of element vectors\n    max.c <- max(apply(C[ ,dim[1:3]]^2, 1, sum)^.5)   # maximal length of construct vectors\n    se <- 1/max.e * scale.e     # scale to unity to make E and C same size\n    sc <- 1/max.c     \n  } \n  if (!unity & !unity3d){\n    se <- 1\n    sc <- 1\n  }\n  Cu <- C * sc\n  Eu <- E * se\n   \n  coords <- rbind(Eu[, dim], Cu[ ,dim], -Cu[ ,dim])\n  colnames(coords) <- c(\"x\", \"y\", \"z\")\n  rownames(coords) <- NULL            # otherwise warning in cbind occurs\n  df <- cbind(df, coords) #, check.rows=F)\n  if (is.na(dim[3]))   # if no 3rd dimension in specified, all values are set to zero i.e. neutral\n    df$z <- 0\n    \n  # plot coords for all points\n  z <- subset(df, type==\"e\", sel=z)                     # z scores for elements\n  #cex.e <- mapCoordinatesToValue(z, e.cex.map)\n  cex.label.e <- mapCoordinatesToValue(z, e.label.cex)\n  cex.point.e <- mapCoordinatesToValue(z, e.point.cex)\n  #color.e <- mapCoordinatesToColor(z, color=e.color, val.range=e.color.map)\n  color.label.e <- mapCoordinatesToColor(z, colors=e.label.col, val.range=e.color.map)\n  color.point.e <- mapCoordinatesToColor(z, colors=e.point.col, val.range=e.color.map)\n  \n  z <- subset(df, type==\"cl\", sel=z)\n  #cex.cl <- mapCoordinatesToValue(z, c.cex.map)\n  cex.label.cl <- mapCoordinatesToValue(z, c.label.cex)\n  cex.point.cl <- mapCoordinatesToValue(z, c.point.cex)  \n  #color.cl <- mapCoordinatesToColor(z, color=c.color, val.range=c.color.map)\n  color.label.cl <- mapCoordinatesToColor(z, colors=c.label.col, val.range=c.color.map)\n  color.point.cl <- mapCoordinatesToColor(z, colors=c.point.col, val.range=c.color.map)\n\n  z <- subset(df, type==\"cr\", sel=z)\n  #cex.cr <- mapCoordinatesToValue(z, c.cex.map)\n  cex.label.cr <- mapCoordinatesToValue(z, c.label.cex)\n  cex.point.cr <- mapCoordinatesToValue(z, c.point.cex)\n  #color.cr <- mapCoordinatesToColor(z, color=c.color, val.range=c.color.map)\n  color.label.cr <- mapCoordinatesToColor(z, colors=c.label.col, val.range=c.color.map)\n  color.point.cr <- mapCoordinatesToColor(z, colors=c.point.col, val.range=c.color.map)\n\n  #df$cex <- unlist(rbind(cex.e, cex.cl, cex.cr))\n  #df$color <- c(color.e, color.cl, color.cr)\n  df$label.col <-  c(color.label.e, color.label.cl, color.label.cr)\n  df$point.col <-  c(color.point.e, color.point.cl, color.point.cr)\n  df$label.cex <-  unlist(c(cex.label.e, cex.label.cl, cex.label.cr))\n  df$point.cex <-  unlist(c(cex.point.e, cex.point.cl, cex.point.cr))\n  df$devangle <- apply(df, 1, function(x) { \n      a <- as.numeric( c(x[\"x\"], x[\"y\"], x[\"z\"]) )\n      n <- c(0,0,1)                              # normal vector for x-y plane\n      degreesBetweenVectorAndPlane(a=a, n=n)\n  })\n  \n  # calculate absolute deviation angle from shown plane. If it is bigger than given values\n  # the constructs will not be shown on the side and/or the construct points will\n  # not be printed. If values >=90 all strokes and points are shown.  \n\n  cs <- subset(df, type %in% c(\"cl\", \"cr\"))\n  draw <- abs(cs$devangle) <= c.labels.devangle   # which angles are smaller or equal than the maximal allowed ones?\n  cs$showlabel <- cs$showlabel & draw             # show only labels that are requested and within allowed angle range\n  draw <- abs(cs$devangle) <= c.points.devangle   # which angles are smaller or equal than the maximal allowed ones?\n  cs$showpoint <- cs$showpoint & draw             # show only labels that are requested and within allowed angle range\n  df[df$type %in% c(\"cl\", \"cr\"), ] <- cs          # show only labels that are requested and within allowed angle range\n\n  # elements #\n  # select which element labels to show\n  # numerical values for element selection are converted to logical\n  seq.e <- seq_len(getNoOfElements(x))\n  if (! (identical(e.labels.show, T) | identical(e.labels.show, F) | all(is.numeric(e.labels.show))) )\n    stop(\"'e.labels.show' must either be a logical value or a numeric vector\")\n  if (all(is.numeric(e.labels.show)))\n    e.labels.show <- seq.e %in% seq.e[e.labels.show]  \n  df[df$type == \"e\", \"showlabel\"] <- e.labels.show   # replace showlabel column for elements\n\n  # select which element points to show\n  # numerical values for element selection are converted to logical\n  if (! (identical(e.points.show, T) | identical(e.points.show, F) | all(is.numeric(e.points.show))) )\n    stop(\"'e.points.show' must either be a logical value or a numeric vector\")\n  if (all(is.numeric(e.points.show)))\n    e.points.show <- seq.e %in% seq.e[e.points.show]  \n  df[df$type == \"e\", \"showpoint\"] <- e.points.show     # replace showpoint column for elements\n\n  # constructs #  TODO: mechanism fill fail for single / double mode grids\n  # select which construct labels to show (independently from devangle)\n  # numerical values for construct selection are converted to logical\n  seq.c <- seq_len(getNoOfConstructs(x))    # TODO for single mode grids\n  if (! (identical(c.labels.show, T) | identical(c.labels.show, F) | all(is.numeric(c.labels.show))) )\n   stop(\"'c.labels.show' must either be a logical value or a numeric vector\")\n  if (all(is.numeric(c.labels.show))){\n    doubleadd <- c.labels.show + sign(c.labels.show[1]) * getNoOfConstructs(x)  # if double mode\n    c.labels.show <- seq.c %in% seq.c[c(c.labels.show, doubleadd)]       \n  }\n  show.tmp <- df[df$type %in% c(\"cl\", \"cr\"), \"showlabel\"] \n  df[df$type %in% c(\"cl\", \"cr\"), \"showlabel\"] <- c.labels.show & show.tmp       # replace showlabel column for elements\n\n  # select which construct points to show (independently from devangle)\n  # numerical values for construct selection are converted to logical\n  if (! (identical(c.points.show, T) | identical(c.points.show, F) | all(is.numeric(c.points.show))) )\n    stop(\"'c.points.show' must either be a logical value or a numeric vector\")\n  if (all(is.numeric(c.points.show)))\n    c.points.show <- seq.c %in% seq.c[c.points.show]  \n  points.tmp <- df[df$type %in% c(\"cl\", \"cr\"), \"showpoint\"]\n  df[df$type %in% c(\"cl\", \"cr\"), \"showpoint\"] <- c.points.show &  points.tmp    # replace showpoint column for elements\n  \n  #list(rg=x, df=df)\n  x@calcs$biplot$e.unity <- Eu\n  x@calcs$biplot$c.unity <- Cu\n  x@plotdata <- df\n  x\n}\n\n\n#' biplotDraw is the workhorse doing the drawing of a 2D biplot. \n#'\n#' When the number of elements and constructs differs to a large extent, the \n#' absolute values of the coordinates for either constructs or elements \n#' will be much smaller or greater. This is an inherent property of the biplot.\n#' In the case it is not necessary to be able to read off the original \n#' data entries from the plot, the axes for elements and constructs\n#' can be scaled seperately. The proportional projection values will \n#' stay unaffetced. the absolue will change though. For grid interpretation \n#' the absolze values are usually oh no importance. Thus, there is an optional\n#' argument \\code{normalize} which is \\code{FALSE} as a default which\n#' rescales the axes so the longest construct and element vector will be \n#' set to the length of \\code{1}.\n#' \n#' @param x                    \\code{repgrid} object.\n#' @param inner.positioning    Logical. Whether to calculate positions to minimize overplotting of \n#'                             elements and construct labels (default is\\code{TRUE}). Note that\n#'                             the positioning may slow down the plotting.\n#' @param outer.positioning    Logical. Whether to calculate positions to minimize overplotting of \n#'                             of construct labels on the outer borders (default is\\code{TRUE}). Note that\n#'                             the positioning may slow down the plotting.\n#' @param c.labels.inside      Logical. Whether to print construct labels next to the points.\n#'                             Can be useful during inspection of the plot (default \\code{FALSE}).\n#' @param flipaxes             Logical vector of length two. Whether x and y axes are reversed \n#'                             (default is \\code{c(F,F)}).\n#' @param strokes.x            Length of outer strokes in x direction in NDC.  \n#' @param strokes.y            Length of outer strokes in y direction in NDC.\n#' @param offsetting           Do offsetting? (TODO)\n#' @param offset.labels        Offsetting parameter for labels (TODO).\n#' @param offset.e             offsetting parameter for elements (TODO).\n#' @param axis.ext             Axis extension factor (default is \\code{.1}). A bigger value will \n#'                             zoom out the plot.\n#' @param mai                  Margins available for plotting the labels in inch \n#'                             (default is \\code{c(.2, 1.5, .2, 1.5)}).\n#' @param rect.margins         Vector of length two (default is \\code{c(.07, .07)}). Two values\n#'                             specifying the additional horizontal and vertical margin around each \n#'                             label.      \n#' @param srt                  Angle to rotate construct label text. Only used in case \\code{offsetting=FALSE}.\n#' @param cex.pos              Cex parameter used during positioning of labels if prompted. Does\n#'                             usually not have to be changed by user.\n#' @param xpd                  Logical (default is \\code{TRUE}). Wether to extend text labels \n#'                             over figure region. Usually not needed by the user.      \n#' @param c.lines              Logical. Whether construct lines from the center of the biplot\n#'                             to the sourrounding box are drawn (default is \\code{FALSE}).\n#' @param col.c.lines          The color of the construct lines from the center to the borders \n#'                             of the plot (default is \\code{gray(.9)}).\n#' @param zoom                 Scaling factor for all vectors. Can be used to zoom\n#'                             the plot in and out (default \\code{1}).\n#' @param ...                  Not evaluated.\n#' @return                     Invisible return of dataframe used during construction of plot \n#'                             (useful for developers).\n#'\n#' @author  Mark Heckmann\n#' @export\n#' @keywords internal\n#'\nbiplotDraw <- function(x, \n                      inner.positioning=TRUE,\n                      outer.positioning=TRUE,\n                      c.labels.inside=F,\n                      flipaxes=c(F,F), \n                      strokes.x=.1, strokes.y=.1, \n                      offsetting=TRUE, offset.labels=.0, offset.e= 1, \n                      axis.ext=.1, mai=c(.2, 1.5, .2, 1.5),\n                      rect.margins=c(.01, .01),\n                      srt=45,\n                      cex.pos=.7,\n                      xpd=TRUE,\n                      c.lines=TRUE,  ### new\n                      col.c.lines=grey(.9),\n                      zoom=1,\n                       ...)\n{\n  y <- showpoint <- showlabel <- type <- NULL       # to prevent 'R CMD check' from noting a missing binding \n                                                    # as the variables are provided in object x as default\n\n  x <- x@plotdata          # df = data frame containing the information for printing\n  \n\tmax.all <- max(abs(x$x), abs(x$y))\n\taxis.ext <- 1 + axis.ext\n  max.ext <- max.all * axis.ext\n\t\n\tx$x <- x$x * zoom     # zoom data\n  x$y <- x$y * zoom     # zoom data\n  \n  # if (! draw.c) \n  #   x$labels[x$type %in% c(\"cl\", \"cr\")] <- \" \"\n\t\n\tlabels.constructs <- x$labels[x$type %in% c(\"cl\", \"cr\")]\n\tlabels.all <- x$labels\n\t\n\tif (flipaxes[1])\n\t  x$x <- x$x * -1\n\tif (flipaxes[2])\n\t  x$y <- x$y * -1\n\t\n\t# build plot\n\told.par <- par(no.readonly = TRUE)      # save parameters\n  #on.exit(par(old.par))                  # reset old par when done\n\t\n\tpar(mai=mai)\n\tplot.new()\n\tplot.window(xlim = c(-max.ext, max.ext), \n\t            ylim = c(-max.ext, max.ext), \n\t            xaxs=\"i\", yaxs=\"i\", asp=1)\n\t\n\t# add center lines and outer rectangle\n\tsegments(-max.ext, 0, max.ext, 0, col=\"lightgrey\")\n\tsegments(0, -max.ext, 0, max.ext, col=\"lightgrey\")\n\trect(-max.ext, -max.ext, max.ext, max.ext)\n\t\n\t# make standard concentration ellipse # TODO, scaling of ellipse\n\t#sing <- diag(esa$sing)[dim] / sum(diag(esa$sing))\n\t#ellipse(sing[1], sing[2], col=\"lightgrey\")\n\n    \n  # initial coords for labels for strokes\n  str.3 <- calcCoordsBorders(x[\"x\"], x[\"y\"], \n                             xmax=max.ext * (1 + strokes.x + offset.labels), # + rect.margins[1]/2), \n                             ymax=max.ext * (1 + strokes.y + offset.labels))# + rect.margins[2]/2))\n  colnames(str.3) <- c(\"str.3.x\", \"str.3.y\")                           \n  x <- cbind(x, str.3)\n  \n  #segments(0,0,x$str.3.x, x$str.3.y)   # debug\n  # calc coordinates for sourrounding rectangles (elements and constructs)\n  lb <- calcRectanglesCoordsForLabels(x[, c(\"str.3.x\", \"str.3.y\")], x$label, \n                                      cex=x$label.cex, x.ext=rect.margins[1], y.ext=rect.margins[2])\n  colnames(lb) <- c(\"str.3.x0\", \"str.3.y0\", \"str.3.x1\", \"str.3.y1\")\n  x <- cbind(x, lb)\n  #segments(x$str.3.x0, x$str.3.y0, x$str.3.x1, x$str.3.y1)   # debug\n  \n    \n  # offset labels in y direction if too close together\n  # for labels on the left and on the right seperately\n  x$angle <- atan2(x$y, x$x)      # caveat: first y, then y argument!\n  x <- x[order(x$angle), ]        # sort by angles\n\n  # assign quandrants for offsetting\n  x$quadrant[x$angle >= 0    & x$angle < pi/2] <- \"ur\"    # \n  x$quadrant[x$angle >= pi/2 & x$angle <= pi] <- \"ul\"     # \n  x$quadrant[x$angle < 0     & x$angle >= -pi/2] <- \"lr\"  # \n  x$quadrant[x$angle < -pi/2 & x$angle >= -pi] <- \"ll\"    # \n  \n  \n  # calc necessary offset (only correct in case there is overlap!)\n  necessaryOffset <- function(a, b, direction=1, margin=.05){\n    if (direction >= 0){        # offset upwards\n      offset <- a[4] - b[2]     # is always positive >= 0\n      if (offset < 0)           # if smaller than zero there should be no overlap anyway\n        offset <- 0\n    } else {                    # offset downwards\n      offset <- a[2] - b[4]     # should always be <= 0\n      if (offset > 0)           # if bigger than zero there is no overlap\n        offset <- 0\n    }\n    as.numeric(offset + margin * sign(direction))\n  }\n  \n  # offset quadrants\n  #lr <- subset(x.sorted, type %in% c(\"cr\", \"cl\") & quadrant==\"lr\")\n  #ol <- lr[, c(\"str.3.x0\", \"str.3.y0\", \"str.3.x1\", \"str.3.y1\")]\n\n  #order.lines <- 1:nrow(ol)\n  #order.lines <- rev(order.lines)\n  \n  # lim <- c(min(ol), max(ol))\n  # plot(0,  type=\"n\", xlim=lim, ylim=lim)\n  # rect(ol[,1], ol[,2], ol[,3], ol[,4])\n  # text(ol[,1], ol[,2], order.lines)\n     \n  offsetQuadrant <- function(x, quadrant=\"ur\", direction=1, \n                             reverse=T, margin=0.02){\n    index <- x$type %in% c(\"cr\", \"cl\") & x$quadrant==quadrant   # get constructs of quandrant\n    \n    ol <- x[index, ]\n    vars <- c(\"str.3.x0\", \"str.3.y0\", \"str.3.x1\", \"str.3.y1\")\n    \n    order.lines <- 1:nrow(ol)\n    if (reverse)\n      order.lines <- rev(order.lines)\n   \n    for (i in order.lines){\n      for (i.n in order.lines){\n        if(i != i.n){\n          overlap <- doRectanglesOverlap(ol[i, vars], ol[i.n, vars])\n          if (overlap){    # if overlap is present the rectangles is moved to avoid overlap\n            offset <- necessaryOffset(ol[i, vars], ol[i.n, vars], dir=direction, margin=margin)\n            ol[i.n, c(\"str.3.y\", \"str.3.y0\",\"str.3.y1\")] <- \n                ol[i.n, c(\"str.3.y\", \"str.3.y0\", \"str.3.y1\")] + offset\n          }\n        }\n      }\n    }\n    \n    x[index, c(\"str.3.y\", vars)] <- ol[, c(\"str.3.y\", vars)]\n    x\n  }\n  \n  # code is slow!\n  if (outer.positioning){\n    x <- offsetQuadrant(x, quadrant=\"ur\", direction=1, reverse=F)    #dir.ur <-  1; reverse <- F \n    x <- offsetQuadrant(x, quadrant=\"ul\", direction=1, reverse=T)    #dir.ul <-  1; reverse <- T\n    x <- offsetQuadrant(x, quadrant=\"ll\", direction=-1, reverse=F)   #dir.ll <- -1; reverse <- F \n    x <- offsetQuadrant(x, quadrant=\"lr\", direction=-1, reverse=T)   #dir.lr <- -1; reverse <- T\n  }\n  # \n  # for (i in order.lines){\n  #   #cat(\"---\\n\")\n  #   for (i.n in order.lines){\n  #     if(i != i.n){\n  #       overlap <- doRectanglesOverlap(ol[i, ], ol[i.n, ])\n  #       #cat(\"(\", i, i.n, \")\", \"\\t\\t\"); print(overlap)\n  #       if (overlap){    # if overlap is present the rectangles is moved to avoid overlap  \n  #         offset <- necessaryOffset(ol[i, ], ol[i.n, ], dir=-1, margin=0.02)\n  #         #print(offset)\n  #         ol[i.n, c(\"str.3.y0\",\"str.3.y1\")] <- \n  #             ol[i.n, c(\"str.3.y0\",\"str.3.y1\")] + offset\n  #       }\n  #     }\n  #   }\n  # }\n\n  # lim <- c(min(ol), max(ol))\n  #   rect(ol[,1], ol[,2], ol[,3], ol[,4], border=\"blue\", lty=2)\n  #   text(ol[,3], ol[,2], order.lines, col=\"blue\" )\n  # \n  # \n  #   plot(0:5)\n  #   rect(ol[4,1],ol[4,2],ol[4,3],ol[4,4])\n  #   rect(ol[3,1],ol[3,2],ol[3,3],ol[3,4])\n  #   doRectanglesOverlap(ol[4,], ol[3,])\n  # do others overlap? If yes move them\n  \n  # make outer strokes for all labels (elements and constructs) \n  # select which to draw later\n  # coordinates for stroke starts\n  str.1 <- calcCoordsBorders(x[\"x\"], x[\"y\"], xmax=max.ext, ymax=max.ext)\n  colnames(str.1) <- c(\"str.1.x\", \"str.1.y\")\n  \n  # coordinates for stroke ends\n  str.2 <- calcCoordsBorders(x[\"x\"], x[\"y\"], xmax=max.ext * (1 + strokes.x), \n                             ymax=max.ext * (1 + strokes.y))\n  colnames(str.2) <- c(\"str.2.x\", \"str.2.y\")\n  \n  x <- cbind(x, str.1, str.2)\n  \n  # redo coordinates for stroke ends according to edges of rectangles that have been offsetted\n  a <- list()\n  for (i in seq_len(nrow(x))){\n    a[[i]] <- calcCoordsBorders(x[i, \"x\"], x[i, \"y\"], xmax=max.ext * (1 + strokes.x), \n                               ymax=abs(x[i, \"str.3.y\"]))\n  }\n  str.4 <- do.call(rbind, a)\n  colnames(str.4) <- c(\"str.4.x\", \"str.4.y\")\n  x <- cbind(x, str.4)\n\n  if (!c.labels.inside){   # when constructs labels are  prompted to be outside the plot(default) \n    # rotate labels srt degress on top and bottom for quick printing\n    y.max.ext <- max.ext * (1 + strokes.y + offset.labels)  # position of outer strokes to determine side of labels\n    x$rotate <- 0                         # default is no rotation of labels in text \n    if (!outer.positioning)               # only for positioning = FALSE to get neater label directions \n      x$rotate[x$str.3.y == y.max.ext |   # replace by standadrd rotation angle\n               x$str.3.y == -y.max.ext] <- srt\n    \n    # only make labels, rectangles and strokes that are prompted\n    cl <- subset(x, type %in% c(\"cl\", \"cr\") & showlabel==T)    # select only labels that should be shown\n    segments(cl$str.1.x, cl$str.1.y, cl$str.2.x, cl$str.2.y, xpd=T)\n    segments(cl$str.2.x, cl$str.2.y, cl$str.4.x, cl$str.4.y, xpd=T, lty=3)\n    rect(cl$str.3.x0, cl$str.3.y0, \n         cl$str.3.x1, cl$str.3.y1, col=grey(1), border=grey(1), xpd=T)\n\n    # print constructs labels (if there are any) and not only inner labels are prompted\n    if (nrow(cl) > 0){\n      for (i in 1:nrow(cl)){\n        if (cl$str.3.x[i] < 0) \n          adj <- c(1, .5) else\n          adj <- c(0, .5)\n        if (!outer.positioning){      # overwrite adj in case of no positioning\n          if (cl$str.3.y[i] == y.max.ext)  \n            adj <- c(0, .5)\n          if (cl$str.3.y[i] == -y.max.ext)  \n            adj <- c(1, .5)\n        }\n        text(cl$str.3.x[i], cl$str.3.y[i], labels=cl$label[i], col=cl$label.col[i], \n             cex=cl$label.cex[i], adj=adj, xpd=T, srt=cl$rotate[i])   \n      }\n    }\n  }\n  \n  \n  ### plotting of elements and contructs inside plot ###\n  \n  #make construct lines if prompted \n  if (c.lines){ \n    cli <- subset(x, type %in% c(\"cl\", \"cr\") & showlabel==T)    # select only labels that should be shown\n    segments(0, 0, cli$str.1.x, cli$str.1.y, col=col.c.lines)   # lines form biplot center to outsides\n  }\n\n  # make construct symbols\n  cs <- subset(x, type %in% c(\"cl\", \"cr\") & showpoint==T & abs(x)<max.ext & abs(y)<max.ext)\n\tpoints(cs[c(\"x\", \"y\")], col=cs$point.col, pch=4, cex=cs$point.cex, xpd=xpd)  \n\n  # make element symbols\n  es <- subset(x, type==\"e\" & showpoint==T & abs(x)<max.ext & abs(y)<max.ext)\n\tpoints(es[c(\"x\", \"y\")], col=es$point.col, pch=15, cex=es$point.cex, xpd=xpd)\n\n\t# positioning of element and constructs labels inside the plot\n\tif (inner.positioning) {    # positioning by landmark algorithm from maptools package\n\t\t\n    # dirty hack as I do not understand the problem why some values become NA: \n    #  replace NAs in showlabel and showpoint. Endas grid #10 produces this\n\t\tx$showlabel[is.na(x$showlabel)] <- TRUE \n\t\tx$showpoint[is.na(x$showpoint)] <- TRUE \n\t\t\n    sh <- subset(x, showlabel==T & showpoint==T)# & \n\t\tlpos <- pointLabel(sh[c(\"x\", \"y\")], labels=sh$label, doPlot=FALSE, cex=cex.pos)     # package maptools\n\t  x$x.pos <- NA\n\t  x$y.pos <- NA\n\t  sh$x.pos <- lpos$x\n\t  sh$y.pos <- lpos$y\t  \n\t  x[x$showlabel==T & x$showpoint==T, ] <- sh\n\t} else {              # simple offsetting in y direction\n\t  x$x.pos <- x$x\n\t  x$y.pos <- NA\n\t  offset.y.pos <- strheight(\"aaaa\", cex=.7)  # string height for dummy string\n\t  x[x$type==\"e\", ]$y.pos <- x[x$type==\"e\", ]$y + offset.y.pos * offset.e  # offset element labels by normal stringheight times x\n\t  x[x$type %in% c(\"cl\", \"cr\"), ]$y.pos <- x[x$type %in% c(\"cl\", \"cr\"), ]$y - .05\n\t}\n\t\n\t# text labels for elements\n\t#es <- subset(x, type==\"e\" & showlabel==T & showpoint==T)   # old version\n\tes <- subset(x, type==\"e\" & showlabel==T & showpoint==T & \n\t             abs(x)<max.ext & abs(y)<max.ext)             # avoid plotting outside plot region\n  if (dim(es)[1] > 0)\n    text(es[, c(\"x.pos\", \"y.pos\")], \n         labels=es$label, col=es$label.col, pch=15, cex=es$label.cex, xpd=xpd)\n  \n  # text labels for constructs inside plot\n  if (c.labels.inside){\n    cs <- subset(x, type %in% c(\"cl\", \"cr\") & showlabel==T \n                 & abs(x)<max.ext & abs(y)<max.ext)\n  \tif (dim(cs)[1] > 0)\n  \ttext(cs[, c(\"x.pos\", \"y.pos\")], \n          labels=cs$label, col=cs$label.col, pch=4, cex=cs$label.cex, xpd=xpd)\n  }\n  invisible(x)    # returns plotdata frame\n}\n# x <- calcBiplotCoords(raeithel, g=1, h=1)\n# x <- prepareBiplotData(x)\n# biplotDraw(x))    # add amount explained variance to the axes\n\n\n\n\n#' Adds the percentage of the sum-of-squares explained by each axis to the plot.\n#' \n#' @param x               \\code{repgrid} object containing the biplot coords, i.e. after \n#'                        having called \\code{\\link{calcBiplotCoords}} and \n#'                        \\code{\\link{prepareBiplotData}}.\n#' @param dim             The dimensions to be printed.\n#' @param var.show        Show explained sum-of-squares in biplot? (default \\code{TRUE}). \n#' @param var.cex         The cex value for the percentages shown in the plot.\n#' @param var.col         The color value of the percentages shown in the plot.\n#' @param axis.ext        Axis extension factor (default is \\code{.1}). A bigger value will \n#'                        zoom out the plot.\n#' @param  center\t\t      Numeric. The type of centering to be performed. \n#'                        0= no centering, 1= row mean centering (construct), \n#'                        2= column mean centering (elements), 3= double-centering (construct and element means),\n#'                        4= midpoint centering of rows (constructs).\n#'                        The default is \\code{1} (row centering).\n#' @param normalize       A numeric value indicating along what direction (rows, columns)\n#'                        to normalize by standard deviations. \\code{0 = none, 1= rows, 2 = columns}\n#'                        (default is \\code{0}).\n#' @param g               Power of the singular value matrix assigned to the left singular \n#'                        vectors, i.e. the constructs.\n#' @param h               Power of the singular value matrix assigned to the right singular \n#'                        vectors, i.e. the elements.\n#' @param col.active      Columns (elements) that are no supplementary points, i.e. they are used\n#'                        in the SVD to find principal components. default is to use all elements.\n#' @param col.passive     Columns (elements) that are supplementary points, i.e. they are NOT used\n#'                        in the SVD but projecte into the component space afterwards. They do not \n#'                        determine the solution. Default is \\code{NA}, i.e. no elements are set \n#'                        supplementary.\n#' @param ...             Not evaluated.\n#'\n#' @author   Mark Heckmann\n#' @keywords internal\n#' @export\n#'\naddVarianceExplainedToBiplot2d <- function(x, dim=c(1,2,3), var.cex=.7, \n                                          var.show=TRUE, var.col=grey(.1), \n                                          axis.ext = .1, \n                                          center=1, normalize=0,\n                                          g=0, h=1-g, \n                                          col.active=NA, \n                                          col.passive=NA, \n                                          ...){  \n  # do only if prompted\n  if (var.show){\n    # determine way to calculate SSQ proportions. \n    # Different if passive columns are used.\n    if(is.na(col.active[1]) & is.na(col.passive[1]))\n      standard.calc.ssq <- TRUE else \n      standard.calc.ssq <- FALSE\n  \n    if (standard.calc.ssq){ \n      # one valid way of calculating the prop SSQ not taking into account passive columns\n      sv <- x@calcs$biplot$D        # get singular values from SVD\n      sv.exp <- sv^2/sum(sv^2)      # proportion of ssq explained per principal component\n      var <- paste(\"Dim \", dim[1:2], \": \", round(sv.exp[dim[1:2]] * 100, 1), \"%\", sep=\"\")\n    } else {\n      # calculating explained variance when passive columns are used\n      ssq.out <- ssq(x, along=2, cum=F, g=g, h=h, \n                     center=center, normalize=normalize, \n                     col.active=col.active, \n                     col.passive=col.passive, print=F, ...)\n      ssq.prop.dim <- ssq.out[dim(ssq.out)[1], dim]\n      var <- paste(\"Dim \", dim[1:2], \": \", \n                   round(ssq.prop.dim[dim[1:2]], 1), \"%\", sep=\"\")\n    }             \n    data <- x@plotdata          # data frame from data prepare function return\n    max.all <- max(abs(data$x), abs(data$y))\n    axis.ext <- 1 + axis.ext\n    max.ext <- max.all * axis.ext\n  \n    ext <- strheight(var[1], cex=var.cex)\n  \n    text(max.ext - ext/2, 0, var[1] , cex=var.cex, adj=c(.5,0), col=var.col, srt=90)\n    text(0, -max.ext + ext/2, var[2] , cex=var.cex, adj=c(.5,0), col=var.col)\n  }\n}\n\n# x <- randomGrid(20, 40)\n# x <- boeker\n# x <- raeithel\n# xb <- prepareBiplotData(x, c.labels.show=F, c.points.dev=90, e.points=1:3, e.labels=T)\n# biplotDraw(xb, xpd=F, inner=F, outer=F)\n# addVarianceExplainedToBiplot(xb$rg, xb$df)\n# \n# xb <- prepareBiplotData(x, c.points.dev=5, c.labels.dev=5)\n# biplotDraw(xb, xpd=F, inner=F, outer=T, mai=rep(0,4), c.labels.inside=T)\n# biplotDraw(xb, xpd=F, inner=F, outer=T)\n# \n# dev.new()\n# xb <- prepareBiplotData(x, dim=c(1,2), map=4)\n# biplotDraw(xb, dev=15)\n# addVarianceExplainedToBiplot(x, xb, dim=c(1,2,4))\n# \n# \n# dev.new()\n# xb <- prepareBiplotData(x, dim=c(2,3), map=1)\n# biplotDraw(xb, dev=15)\n# addVarianceExplainedToBiplot(x, xb, dim=c(2,3,1))\n# \n# dev.new()\n# xb <- prepareBiplotData(x, dim=c(3,4), map=1)\n# biplotDraw(xb, dev=15)\n# addVarianceExplainedToBiplot(x, xb, dim=c(3,4,1))\n\n# x <- boeker\n# x <- prepareBiplotData(x, e.col=\"black\", c.col=\"black\", cex.e=.7, cex.c=.7)#, color.e=.8, color.c=.8)\n# biplotDraw(x)\n# addVarianceExplainedToBiplot(boeker, x)\n# \n# x <- boeker\n# x <- prepareBiplotData(x, e.col=\"black\", c.col=\"black\", cex.e=.7, cex.c=.7, \n#                         color.e=.3, color.c=.5)\n# biplotDraw(x)\n# addVarianceExplainedToBiplot(boeker, x)\n# \n# x <- boeker\n# x <- prepareBiplotData(x, e.col=\"black\", c.col=\"black\", cex.e=c(.3,1))\n# x <- prepareBiplotData(x, e.col=\"black\", c.col=\"black\",  cex.e=c(.3,1), cex.c=c(.3,1))\n# x <- prepareBiplotData(x, cex.e=c(.5,1.3), cex.c=c(.5,1.3))\n# x <- prepareBiplotData(x, cex.e=c(.5,1), cex.c=c(.5,1), color.c.map=c(0, 0))\n# biplotDraw2(x)\n# \n# x <- boeker\n# x <- raeithel\n# \n# layout(matrix(1:4, by=T, ncol=2))\n# \n# xb <- prepareBiplotData(x, dim=c(1,2), map=3)\n# biplotDraw(xb)\n# addVarianceExplainedToBiplot(x, xb, dim=1:3)\n# \n# xb <- prepareBiplotData(x, dim=c(2,3), map=1)\n# biplotDraw(xb)\n# addVarianceExplainedToBiplot(x, xb, dim=c(2,3,1))\n# \n# xb <- prepareBiplotData(x, dim=c(3,4), map=1)\n# biplotDraw(xb)\n# addVarianceExplainedToBiplot(x, xb, dim=c(3,4,1))\n# \n# xb <- prepareBiplotData(x, dim=c(1,4), map=2)\n# biplotDraw(xb)\n# addVarianceExplainedToBiplot(x, xb, dim=c(1,4,2))\n\n\n\n\n#' Draw a two-dimensional biplot. \n#'\n#' The biplot is the central\n#' way to create a joint plot of elements and constructs.\n#' Depending on te parameters chosen it contains information\n#' on the distances between elements and constructs. Also the \n#' relative values the elements have on a construct can be read off\n#' by projetion the element onto the construct vector. \n#' A lot of parameters can be changed rendering\n#' different types of biplots (ESA, Slater's) and different \n#' looks (colors, text size).\n#' See the example section below to get started.\n#'\n#' For the construction of a biplot the grid matrix is first\n#' centered and normalized according to the prompted options.\\cr \n#' Next, the matrix is decomposed by singular value decomposition (SVD)\n#' into \\deqn{X = UDV^T}{X = UDV^T}\n#' The biplot is made up of two matrices \n#' \\deqn{X = GH^T}{X = GH^T}\n#' These matrices are construed on the basis of the SVD results.\n#' \\deqn{\\hat{X} = UD^gD^hV^T}{X = UD^gD^hV^T}\n#' Note that the grid matrix values are only recovered and \n#' the projection property is only given if \\eqn{g + h = 1}{g + h = 1}\n#' \n#'\n#' @param x                   \\code{repgrid} object.\n#' @param dim                 Dimensions (i.e. principal components) to be used for biplot \n#'                            (default is \\code{c(1,2)}).\n#' @param map.dim             Third dimension (depth) used to map aesthetic attributes to\n#'                            (default is \\code{3}).\n#' @param  center\t\t          Numeric. The type of centering to be performed. \n#'                            0= no centering, 1= row mean centering (construct), \n#'                            2= column mean centering (elements), 3= double-centering (construct and element means),\n#'                            4= midpoint centering of rows (constructs).\n#'                            The default is \\code{1} (row centering).\n#' @param normalize           A numeric value indicating along what direction (rows, columns)\n#'                            to normalize by standard deviations. \\code{0 = none, 1= rows, 2 = columns}\n#'                            (default is \\code{0}).\n#' @param g                   Power of the singular value matrix assigned to the left singular \n#'                            vectors, i.e. the constructs.\n#' @param h                   Power of the singular value matrix assigned to the right singular \n#'                            vectors, i.e. the elements.\n#' @param col.active          Columns (elements) that are no supplementary points, i.e. they are used\n#'                            in the SVD to find principal components. default is to use all elements.\n#' @param col.passive         Columns (elements) that are supplementary points, i.e. they are NOT used\n#'                            in the SVD but projecte into the component space afterwards. They do not \n#'                            determine the solution. Default is \\code{NA}, i.e. no elements are set \n#'                            supplementary.\n#' @param e.point.col         Color of the element symbols. The default is \\code{\"black\"}.\n#'                            Two values can be entered that will create a color ramp. The values of \n#'                            \\code{map.dim} are mapped onto the ramp.\n#'                            If only one color color value is supplied (e.g. \\code{\"black\"}) \n#'                            no mapping occurs and all elements will have the same color \n#'                            irrespective of their value on the \\code{map.dim} dimension.\n#' @param e.point.cex         Size of the element symbols. The default is \\code{.9}.\n#'                            Two values can be entered that will create a size ramp. The values of \n#'                            \\code{map.dim} are mapped onto the ramp.\n#'                            If only one color size value is supplied (e.g. \\code{.8}) \n#'                            no mapping occurs and all elements will have the same size \n#'                            irrespective of their value on the \\code{map.dim} dimension.\n#' @param e.label.col         Color of the element label. The default is \\code{\"black\"}.\n#'                            Two values can be entered that will create a color ramp. The values of \n#'                            \\code{map.dim} are mapped onto the ramp.\n#'                            If only one color color value is supplied (e.g. \\code{\"black\"}) \n#'                            no mapping occurs and all labels will have the same color \n#'                            irrespective of their value on the \\code{map.dim} dimension.\n#' @param e.label.cex         Size of the element labels. The default is \\code{.7}.\n#'                            Two values can be entered that will create a size ramp. The values of \n#'                            \\code{map.dim} are mapped onto the ramp.\n#'                            If only one color size value is supplied (e.g. \\code{.7}) \n#'                            no mapping occurs and all labels will have the same size \n#'                            irrespective of their value on the \\code{map.dim} dimension.\n#' @param e.color.map         Value range to determine what range of the color ramp defined in \n#'                            \\code{e.color} will be used for mapping the colors. \n#'                            Default is \\code{c(.4, ,1)}. Usually not important for the user. \n#' @param c.point.col         Color of the construct symbols. The default is \\code{\"black\"}.\n#'                            Two values can be entered that will create a color ramp. The values of \n#'                            \\code{map.dim} are mapped onto the ramp.\n#'                            If only one color color value is supplied (e.g. \\code{\"black\"}) \n#'                            no mapping occurs and all construct will have the same color \n#'                            irrespective of their value on the \\code{map.dim} dimension.\n#' @param c.point.cex         Size of the construct symbols. The default is \\code{.8}.\n#'                            Two values can be entered that will create a size ramp. The values of \n#'                            \\code{map.dim} are mapped onto the ramp.\n#'                            If only one color size value is supplied (e.g. \\code{.8}) \n#'                            no mapping occurs and all construct will have the same size \n#'                            irrespective of their value on the \\code{map.dim} dimension.\n#' @param c.label.col         Color of the construct label. The default is \\code{\"black\"}.\n#'                            Two values can be entered that will create a color ramp. The values of \n#'                            \\code{map.dim} are mapped onto the ramp.\n#'                            If only one color color value is supplied (e.g. \\code{\"black\"}) \n#'                            no mapping occurs and all labels will have the same color \n#'                            irrespective of their value on the \\code{map.dim} dimension.\n#' @param c.label.cex         Size of the construct labels. The default is \\code{.7}.\n#'                            Two values can be entered that will create a size ramp. The values of \n#'                            \\code{map.dim} are mapped onto the ramp.\n#'                            If only one color size value is supplied (e.g. \\code{.7}) \n#'                            no mapping occurs and all labels will have the same size \n#'                            irrespective of their value on the \\code{map.dim} dimension.\n#' @param c.color.map         Value range to determine what range of the color ramp defined in \n#'                            \\code{c.color} will be used for mapping. Default is \\code{c(.4, ,1)}.\n#'                            Usually not important for the user.\n#' @param c.points.devangle   The deviation angle from the x-y plane in degrees. These can only be calculated\n#'                            if a third dimension \\code{map.dim} is specified. Only the constructs \n#'                            that do not depart more than the specified degrees from the \n#'                            x-y plane will be printed. This facilitates the visual \n#'                            interpretation, as only vectors represented near the current plane \n#'                            are shown. Set the value to \\code{91} (default) \n#'                            to show all vectors.\n#' @param c.labels.devangle   The deviation angle from the x-y plane in degrees. These can only be calculated\n#'                            if a third dimension \\code{map.dim} is specified. Only the labels of constructs \n#'                            that do not depart more than the specified degrees from the \n#'                            x-y plane will be printed. Set the value to \\code{91} (default) \n#'                            to show all construct labels.\n#' @param c.points.show       Whether the constructs are printed (default is \\code{TRUE}).\n#'                            \\code{FALSE} will surpress the printing of the constructs.\n#'                            To only print certain constructs a numeric vector can be \n#'                            provided (e.g. \\code{c(1:10)}).\n#' @param c.labels.show       Whether the construct labels are printed (default is \\code{TRUE}).\n#'                            \\code{FALSE} will surpress the printing of the labels.\n#'                            To only print certain construct labels a numeric vector can be \n#'                            provided (e.g. \\code{c(1:10)}).\n#' @param e.points.show       Whether the elements are printed (default is \\code{TRUE}).\n#'                            \\code{FALSE} will surpress the printing of the elements.\n#'                            To only print certain elements a numeric vector can be \n#'                            provided (e.g. \\code{c(1:10)}).\n#' @param e.labels.show       Whether the element labels are printed (default is \\code{TRUE}).\n#'                            \\code{FALSE} will surpress the printing of the labels.\n#'                            To only print certain element labels a numeric vector can be \n#'                            provided (e.g. \\code{c(1:10)}).\n#' @param inner.positioning   Logical. Whether to calculate positions to minimize overplotting of \n#'                            elements and construct labels (default is\\code{TRUE}). Note that\n#'                            the positioning may slow down the plotting.\n#' @param outer.positioning   Logical. Whether to calculate positions to minimize overplotting of \n#'                            of construct labels on the outer borders (default is\\code{TRUE}). Note that\n#'                            the positioning may slow down the plotting.\n#' @param c.labels.inside     Logical. Whether to print construct labels next to the points.\n#'                            Can be useful during inspection of the plot (default \\code{FALSE}).\n#' @param c.lines             Logical. Whether construct lines from the center of the biplot\n#'                            to the sourrounding box are drawn (default is \\code{FALSE}).\n#' @param col.c.lines         The color of the construct lines from the center to the borders \n#'                            of the plot (default is \\code{gray(.9)}).\n#' @param flipaxes            Logical vector of length two. Whether x and y axes are reversed \n#'                            (default is \\code{c(F,F)}).\n#' @param strokes.x           Length of outer strokes in x direction in NDC.  \n#' @param strokes.y           Length of outer strokes in y direction in NDC.\n#' @param offsetting          Do offsetting? (TODO)\n#' @param offset.labels       Offsetting parameter for labels (TODO).\n#' @param offset.e            offsetting parameter for elements (TODO).\n#' @param axis.ext            Axis extension factor (default is \\code{.1}). A bigger value will \n#'                            zoom out the plot.\n#' @param mai                 Margins available for plotting the labels in inch \n#'                            (default is \\code{c(.2, 1.5, .2, 1.5)}).\n#' @param rect.margins        Vector of length two (default is \\code{c(.07, .07)}). Two values\n#'                            specifying the additional horizontal and vertical margin around each \n#'                            label.      \n#' @param srt                 Angle to rotate construct label text. Only used in case \\code{offsetting=FALSE}.\n#' @param cex.pos             Cex parameter used during positioning of labels if prompted. Does\n#'                            usually not have to be changed by user.\n#' @param xpd                 Logical (default is \\code{TRUE}). Wether to extend text labels \n#'                            over figure region. Usually not needed by the user.\n#' @param unity               Scale elements and constructs coordinates to unit scale in 2D (maximum of 1)\n#'                            so they are printed more neatly (default \\code{TRUE}).\n#' @param unity3d             Scale elements and constructs coordinates to unit scale in 3D (maximum of 1)\n#'                            so they are printed more neatly (default \\code{TRUE}).\n#' @param scale.e             Scaling factor for element vectors. Will cause element points to move a bit more\n#'                            to the center. (but only if \\code{unity} or \\code{unity3d} is \\code{TRUE}).\n#'                            This argument is for visual appeal only.\n#' @param zoom                Scaling factor for all vectors. Can be used to zoom\n#'                            the plot in and out (default \\code{1}).\n#' @param var.show            Show explained sum-of-squares in biplot? (default \\code{TRUE}). \n#' @param var.cex             The cex value for the percentages shown in the plot.\n#' @param var.col             The color value of the percentages shown in the plot.\n#' @param ...                 parameters passed on to  come.\n#'\n#' @author                    Mark Heckmann\n#' @export\n#'\n#' @seealso   Unsophisticated biplot: \\code{\\link{biplotSimple}}; \\cr\n#'            2D biplots:\n#'            \\code{\\link{biplot2d}},\n#'            \\code{\\link{biplotEsa2d}},\n#'            \\code{\\link{biplotSlater2d}};\\cr\n#'            Pseudo 3D biplots:\n#'            \\code{\\link{biplotPseudo3d}},  \n#'            \\code{\\link{biplotEsaPseudo3d}},\n#'            \\code{\\link{biplotSlaterPseudo3d}};\\cr\n#'            Interactive 3D biplots:\n#'            \\code{\\link{biplot3d}},\n#'            \\code{\\link{biplotEsa3d}},\n#'            \\code{\\link{biplotSlater3d}};\\cr\n#'            Function to set view in 3D:\n#'            \\code{\\link{home}}.  \n#'\n#' @examples \\dontrun{\n#'\n#'    biplot2d(boeker)                # biplot of boeker data\n#'    biplot2d(boeker, c.lines=T)     # add construct lines\n#'    biplot2d(boeker, center=2)      # with column centering\n#'    biplot2d(boeker, center=4)      # midpoint centering\n#'    biplot2d(boeker, normalize=1)   # normalization of constructs\n#'\n#'    biplot2d(boeker, dim=2:3)       # plot 2nd and 3rd dimension\n#'    biplot2d(boeker, dim=c(1,4))    # plot 1st and 4th dimension\n#'\n#'    biplot2d(boeker, g=1, h=1)            # assign singular values to con. & elem.\n#'    biplot2d(boeker, g=1, h=1, center=1)  # row centering (Slater)\n#'    biplot2d(boeker, g=1, h=1, center=4)  # midpoint centering (ESA)\n#'\n#'    biplot2d(boeker, e.color=\"red\", c.color=\"blue\")   # change colors\n#'    biplot2d(boeker, c.color=c(\"white\", \"darkred\"))   # mapped onto color range\n#'    \n#'    biplot2d(boeker, unity=T)                 # scale con. & elem. to equal length\n#'    biplot2d(boeker, unity=T, scale.e=.5)     # scaling factor for element vectors\n#'\n#'    biplot2d(boeker, e.labels.show=F)         # do not show element labels\n#'    biplot2d(boeker, e.labels.show=c(1,2,4))  # show labels for elements 1, 2 and 4\n#'    biplot2d(boeker, e.points.show=c(1,2,4))  # only show elements 1, 2 and 4\n#'    biplot2d(boeker, c.labels.show=c(1:4))    # show constructs labels 1 to 4   \n#'    biplot2d(boeker, c.labels.show=c(1:4))    # show constructs labels except 1 to 4\n#'\n#'    biplot2d(boeker, e.cex.map=1)   # change size of texts for elements \n#'    biplot2d(boeker, c.cex.map=1)   # change size of texts for constructs \n#'\n#'    biplot2d(boeker, g=1, h=1, c.labels.inside=T)  # constructs inside the plot\n#'    biplot2d(boeker, g=1, h=1, c.labels.inside=T,  # different margins and elem. color \n#'             mai=c(0,0,0,0), e.color=\"red\") \n#'  \n#'    biplot2d(boeker, strokes.x=.3, strokes.y=.05)  # change length of strokes\n#'\n#'    biplot2d(boeker, flipaxes=c(T, F))      # flip x axis\n#'    biplot2d(boeker, flipaxes=c(T, T))      # flip x and y axis\n#'\n#'    biplot2d(boeker, outer.positioning=F)   # no positioning of con.-labels\n#'\n#'    biplot2d(boeker, c.labels.devangle=20)  # only con. within 20 degree angle\n#' } \n#'\nbiplot2d <- function(x, dim=c(1,2), map.dim=3, \n                    center=1,\n                    normalize=0, \n                    g=0, \n                    h=1-g, \n                    col.active=NA, \n                    col.passive=NA,\n                    #e.color=\"black\", \n                    #c.color=\"black\",   \n                    e.point.col=\"black\",\n                    e.point.cex=.9,\n                    e.label.col=\"black\",\n                    e.label.cex=.7,   \n                    e.color.map=c(.4, 1),               \n                    c.point.col=\"black\",\n                    c.point.cex=.8,\n                    c.label.col=\"black\",\n                    c.label.cex=.7,\n                    c.color.map=c(.4, 1),\n                    #e.cex.map=.7,\n                    #c.cex.map=.7,\n                    c.points.devangle=91,\n                    c.labels.devangle=91,\n                    c.points.show=TRUE,\n                    c.labels.show=TRUE,\n                    e.points.show=TRUE,\n                    e.labels.show=TRUE,\n                    inner.positioning=TRUE,\n                    outer.positioning=TRUE,\n                    c.labels.inside=FALSE,\n                    c.lines=TRUE, \n                    col.c.lines=grey(.9),\n                    flipaxes=c(FALSE,FALSE), \n                    strokes.x=.1, strokes.y=.1, \n                    offsetting=TRUE, offset.labels=.0, offset.e= 1, \n                    axis.ext=.1, mai=c(.2, 1.5, .2, 1.5),\n                    rect.margins=c(.01, .01),\n                    srt=45,\n                    cex.pos=.7,\n                    xpd=TRUE, \n                    unity=FALSE, \n                    unity3d=FALSE,\n                    scale.e=.9,\n                    zoom=1,\n                    var.show=TRUE, \n                    var.cex=.7, \n                    var.col=grey(.1),  \n                    ...)\n{\n  x <- calcBiplotCoords(x, center=center, normalize=normalize, \n                        g=g, h=h, \n                        col.active=col.active, col.passive=col.passive, ...)\n  x <- prepareBiplotData(x, dim=dim, map.dim=map.dim, \n                          e.label.cex=e.label.cex,  c.label.cex=c.label.cex,\n                          e.label.col=e.label.col,  c.label.col=c.label.col,\n                          e.point.cex=e.point.cex,  c.point.cex=c.point.cex,\n                          e.point.col=e.point.col,  c.point.col=c.point.col,\n                          #e.color=e.color, c.color=c.color,\n                          #e.cex.map=e.cex.map, c.cex.map=c.cex.map, \n                          e.color.map=e.color.map, c.color.map=c.color.map, \n                          c.points.devangle=c.points.devangle,\n                          c.labels.devangle=c.labels.devangle, c.points.show=c.points.show,\n                          c.labels.show=c.labels.show, \n                          e.points.show=e.points.show,\n                          e.labels.show=e.labels.show, \n                          unity=unity, unity3d=unity3d, scale.e=scale.e, ...)\n  biplotDraw(x, inner.positioning=inner.positioning, outer.positioning=outer.positioning,\n             c.labels.inside=c.labels.inside, \n             c.lines=c.lines, col.c.lines=col.c.lines, flipaxes=flipaxes, \n             strokes.x=strokes.x, strokes.y=strokes.y, \n             offsetting=offsetting, offset.labels=offset.labels, offset.e=offset.e, \n             axis.ext=axis.ext, mai=mai, rect.margins=rect.margins,\n             srt=srt, cex.pos=cex.pos, xpd=xpd, zoom=zoom)\n  addVarianceExplainedToBiplot2d(x, dim=dim, center=center, normalize=normalize, \n                                 g=g, h=h, col.active=col.active, \n                                 col.passive=col.passive, var.show=var.show,\n                                 var.cex=var.cex, var.col=var.col, ...)\n  invisible(x)                                           \n}\n\n\n#' See \\code{\\link{biplotPseudo3d}} for its use.\n\n#' Draws a biplot of the grid in 2D with depth impression (pseudo 3D).\n#'\n#' This version is basically a 2D biplot. \n#' It only modifies color and size of the symbols in order to create a 3D impression\n#' of the data points. \n#' This function will call the standard \\code{\\link{biplot2d}} function with some \n#' modified arguments. For the whole set of arguments that can be used\n#' see \\code{\\link{biplot2d}}. Here only the arguments special to \n#' \\code{biplotPseudo3d} are outlined.\n#'\n#' @param x             \\code{repgrid} object.\n#' @param dim           Dimensions (i.e. principal components) to be used for biplot \n#'                      (default is \\code{c(1,2)}).\n#' @param map.dim       Third dimension (depth) used to map aesthetic attributes to\n#'                      (default is \\code{3}).\n#' @param e.point.col   Color(s) of the element symbols. Two values can be entered that will\n#'                      create a color ramp. The values of \\code{map.dim} are mapped onto the ramp.\n#'                      The default is \\code{c(\"white\", \"black\")}. If only one color color value\n#'                      is supplied (e.g. \\code{\"black\"}) no mapping occurs and all elements\n#'                      will have the same color irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param e.point.cex   Size of the element symbols. Two values can be entered that will\n#'                      represents the lower and upper size of a range of cex the values of \\code{map.dim} \n#'                      are mapped onto. The default is \\code{c(.6, 1.2)}. If only one cex value\n#'                      is supplied (e.g. \\code{.7}) no mapping occurs and all elements\n#'                      will have the same size irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param e.label.col   Color(s) of the element labels. Two values can be entered that will\n#'                      create a color ramp. The values of \\code{map.dim} are mapped onto the ramp.\n#'                      The default is \\code{c(\"white\", \"black\")}. If only one color color value\n#'                      is supplied (e.g. \\code{\"black\"}) no mapping occurs and all element labels\n#'                      will have the same color irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param e.label.cex   Size of the element labels. Two values can be entered that will\n#'                      represents the lower and upper size of a range of cex the values of \\code{map.dim} \n#'                      are mapped onto. The default is \\code{c(.6, .8)}. If only one cex value\n#'                      is supplied (e.g. \\code{.7}) no mapping occurs and all element labels\n#'                      will have the same size irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param e.color.map   Value range to determine what range of the color ramp defined in \n#'                      \\code{e.color} will be used for mapping the colors. \n#'                      Default is \\code{c(.4, ,1)}. Usually not important for the user. \n#' @param c.point.col   Color(s) of the construct symbols. Two values can be entered that will\n#'                      create a color ramp. The values of \\code{map.dim} are mapped onto the ramp.\n#'                      The default is \\code{c(\"white\", \"darkred\")}. If only one color color value\n#'                      is supplied (e.g. \\code{\"black\"}) no mapping occurs and all elements\n#'                      will have the same color irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param c.point.cex   Size of the construct symbols. Two values can be entered that will\n#'                      represents the lower and upper size of a range of cex the values of \\code{map.dim} \n#'                      are mapped onto. The default is \\code{c(.6, 1.2)}. If only one cex value\n#'                      is supplied (e.g. \\code{.7}) no mapping occurs and all elements\n#'                      will have the same size irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param c.label.col   Color(s) of the construct labels. Two values can be entered that will\n#'                      create a color ramp. The values of \\code{map.dim} are mapped onto the ramp.\n#'                      The default is \\code{c(\"white\", \"black\")}. If only one color color value\n#'                      is supplied (e.g. \\code{\"black\"}) no mapping occurs and all construct labels\n#'                      will have the same color irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param c.label.cex   Size of the construct labels. Two values can be entered that will\n#'                      represents the lower and upper size of a range of cex the values of \\code{map.dim} \n#'                      are mapped onto. The default is \\code{c(.6, .9)}. If only one cex value\n#'                      is supplied (e.g. \\code{.7}) no mapping occurs and all construct labels\n#'                      will have the same size irrespective of their value on the \\code{map.dim}\n#'                      dimension.\n#' @param c.color.map   Value range to determine what range of the color ramp defined in \n#'                      \\code{c.color} will be used for mapping. Default is \\code{c(.4, ,1)}.\n#'                      Usually not important for the user.\n#' @param ...           Additional parameters passed to \\code{\\link{biplot2d}}.\n#'  \n#' @author              Mark Heckmann\n#' @export\n#'\n#' @seealso   Unsophisticated biplot: \\code{\\link{biplotSimple}}; \\cr\n#'            2D biplots:\n#'            \\code{\\link{biplot2d}},\n#'            \\code{\\link{biplotEsa2d}},\n#'            \\code{\\link{biplotSlater2d}};\\cr\n#'            Pseudo 3D biplots:\n#'            \\code{\\link{biplotPseudo3d}},  \n#'            \\code{\\link{biplotEsaPseudo3d}},\n#'            \\code{\\link{biplotSlaterPseudo3d}};\\cr\n#'            Interactive 3D biplots:\n#'            \\code{\\link{biplot3d}},\n#'            \\code{\\link{biplotEsa3d}},\n#'            \\code{\\link{biplotSlater3d}};\\cr\n#'            Function to set view in 3D:\n#'            \\code{\\link{home}}.\n#'\n#' @examples \\dontrun{\n#'    # biplot with 3D impression\n#'    biplotPseudo3d(boeker)    \n#'    # Slater's biplot with 3D impression                  \n#'    biplotPseudo3d(boeker, g=1, h=1, center=1)  \n#'\n#'    # show 2nd and 3rd dim. and map 4th \n#'    biplotPseudo3d(boeker, dim=2:3, map.dim=4)  \n#'\n#'    # change elem. colors\n#'    biplotPseudo3d(boeker, e.color=c(\"white\", \"darkgreen\"))\n#'    # change con. colors \n#'    biplotPseudo3d(boeker, c.color=c(\"white\", \"darkgreen\")) \n#'    # change color mapping range\n#'    biplotPseudo3d(boeker, c.colors.map=c(0, 1))            \n#'\n#'    # set uniform con. text size\n#'    biplotPseudo3d(boeker, c.cex=1)     \n#'    # change text size mapping range        \n#'    biplotPseudo3d(boeker, c.cex=c(.4, 1.2))    \n#' }\n#'\nbiplotPseudo3d <- function( x, dim=1:2, map.dim=3, \n                            e.point.col=c(\"white\", \"black\"),\n                            e.point.cex=c(.6, 1.2),\n                            e.label.col=c(\"white\", \"black\"),\n                            e.label.cex=c(.6, .8),   \n                            e.color.map=c(.4, 1),               \n                            c.point.col=c(\"white\", \"darkred\"),\n                            c.point.cex=c(.6, 1.2),\n                            c.label.col=c(\"white\", \"darkred\"),\n                            c.label.cex=c(.6, .8),\n                            c.color.map=c(.4, 1),\n                            ...)\n{            \n  biplot2d(x=x, dim=dim, map.dim=map.dim, \n            e.point.col=e.point.col,\n            e.point.cex=e.point.cex,\n            e.label.col=e.label.col,\n            e.label.cex=e.label.cex, \n            e.color.map=e.color.map,                                   \n            c.point.col=c.point.col,\n            c.point.cex=c.point.cex,\n            c.label.col=c.label.col,\n            c.label.cex=c.label.cex,\n            c.color.map=c.color.map, \n            ...)\n}\n\n    \n#' Draws Slater's INGRID biplot in 2D. \n#'\n#' The default is to use row centering \n#' and no normalization. Note that Slater's biplot is just a \n#' special case of a biplot\n#' that can be produced using the \\code{\\link{biplot2d}} function with the arguments\n#' \\code{center=1, g=1, h=1}. The arguments that can be used in this function\n#' are the same as in \\code{\\link{biplot2d}}. \n#' Here, only the arguments that are set for Slater's biplot are described.\n#' To see all the parameters that can be changed see \\code{\\link{biplot2d}}.\n#'\n#' @param x           \\code{repgrid} object.\n#' @param  center\t\t  Numeric. The type of centering to be performed. \n#'                    0= no centering, 1= row mean centering (construct), \n#'                    2= column mean centering (elements), 3= double-centering (construct and element means),\n#'                    4= midpoint centering of rows (constructs).\n#'                    Slater's biplot uses \\code{1} (row centering).\n#' @param g           Power of the singular value matrix assigned to the left singular \n#'                    vectors, i.e. the constructs.\n#' @param h           Power of the singular value matrix assigned to the right singular \n#'                    vectors, i.e. the elements.\n#' @param ...         Additional parameters for be passed to \\code{\\link{biplot2d}}.\n#'\n#' @author            Mark Heckmann\n#' @export\n#'\n#' @seealso   Unsophisticated biplot: \\code{\\link{biplotSimple}}; \\cr\n#'            2D biplots:\n#'            \\code{\\link{biplot2d}},\n#'            \\code{\\link{biplotEsa2d}},\n#'            \\code{\\link{biplotSlater2d}};\\cr\n#'            Pseudo 3D biplots:\n#'            \\code{\\link{biplotPseudo3d}},  \n#'            \\code{\\link{biplotEsaPseudo3d}},\n#'            \\code{\\link{biplotSlaterPseudo3d}};\\cr\n#'            Interactive 3D biplots:\n#'            \\code{\\link{biplot3d}},\n#'            \\code{\\link{biplotEsa3d}},\n#'            \\code{\\link{biplotSlater3d}};\\cr\n#'            Function to set view in 3D:\n#'            \\code{\\link{home}}.\n#'\n#' @examples \\dontrun{\n#'    # See examples in \\code{\\link{biplot2d}} as the same arguments\n#'    # can used for this function.\n#' }\n#'\nbiplotSlater2d <- function(x, center=1, g=1, h=1, ...){\n  biplot2d(x=x, center=center, g=g, h=h, ...)\n}\n\n\n#' Draws Slater's biplot in 2D with depth impression (pseudo 3D).\n#'\n#' The default is to use row centering \n#' and no normalization. Note that Slater's biplot is just a special \n#' case of a biplot that can be produced using the \\code{\\link{biplotPseudo3d}} \n#' function with the arguments \\code{center=1, g=1, h=1}.\n#' Here, only the arguments that are modified for Slater's biplot are described.\n#' To see all the parameters that can be changed see \\code{\\link{biplot2d}}\n#' and \\code{\\link{biplotPseudo3d}}.\n#'\n#' @param x           \\code{repgrid} object.\n#' @param  center\t\t  Numeric. The type of centering to be performed. \n#'                    0= no centering, 1= row mean centering (construct), \n#'                    2= column mean centering (elements), 3= double-centering (construct and element means),\n#'                    4= midpoint centering of rows (constructs).\n#'                    Slater's biplot uses \\code{1} (row centering).\n#' @param g           Power of the singular value matrix assigned to the left singular \n#'                    vectors, i.e. the constructs.\n#' @param h           Power of the singular value matrix assigned to the right singular \n#'                    vectors, i.e. the elements.\n#' @param ...         Additional parameters for be passed to \\code{\\link{biplotPseudo3d}}.\n#'\n#' @author            Mark Heckmann\n#' @export\n#'\n#' @seealso   Unsophisticated biplot: \\code{\\link{biplotSimple}}; \\cr\n#'            2D biplots:\n#'            \\code{\\link{biplot2d}},\n#'            \\code{\\link{biplotEsa2d}},\n#'            \\code{\\link{biplotSlater2d}};\\cr\n#'            Pseudo 3D biplots:\n#'            \\code{\\link{biplotPseudo3d}},  \n#'            \\code{\\link{biplotEsaPseudo3d}},\n#'            \\code{\\link{biplotSlaterPseudo3d}};\\cr\n#'            Interactive 3D biplots:\n#'            \\code{\\link{biplot3d}},\n#'            \\code{\\link{biplotEsa3d}},\n#'            \\code{\\link{biplotSlater3d}};\\cr\n#'            Function to set view in 3D:\n#'            \\code{\\link{home}}.\n#'\n#' @examples \\dontrun{\n#'    # See examples in \\code{\\link{biplotPseudo3d}} as the same arguments\n#'    # can used for this function.\n#' }\n#'\nbiplotSlaterPseudo3d <- function(x, center=1, g=1, h=1, ...){\n  biplotPseudo3d(x=x, center=center, g=g, h=h, ...)\n}\n\n\n\n#' Plot an eigenstructure analysis (ESA) biplot in 2D.\n#' \n#' The ESA is a special type of biplot suggested by Raeithel (e.g. 1998).\n#' It uses midpoint centering as a default. Note that the eigenstructure analysis\n#' is just a special case of a biplot that can also be produced using the \n#' \\code{\\link{biplot2d}} function with the arguments \n#' \\code{center=4, g=1, h=1}.\n#' Here, only the arguments that are modified for the ESA biplot are described.\n#' To see all the parameters that can be changed see \\code{\\link{biplot2d}}.\n#'\n#' @param x           \\code{repgrid} object.\n#' @param  center\t\t  Numeric. The type of centering to be performed. \n#'                    0= no centering, 1= row mean centering (construct), \n#'                    2= column mean centering (elements), 3= double-centering (construct and element means),\n#'                    4= midpoint centering of rows (constructs).\n#'                    Eigenstructure analyis uses midpoint centering (\\code{4}).\n#' @param g           Power of the singular value matrix assigned to the left singular \n#'                    vectors, i.e. the constructs. Eigenstructure analyis uses  \n#'                    \\code{g=1}.\n#' @param h           Power of the singular value matrix assigned to the right singular \n#'                    vectors, i.e. the elements. Eigenstructure analyis uses  \n#'                    \\code{h=1}.\n#' @param ...         Additional parameters for be passed to \\code{\\link{biplot2d}}.\n#'\n#' @references   Raeithel, A. (1998). Kooperative Modellproduktion von Professionellen \n#'                und Klienten. Erlaeutert am Beispiel des Repertory Grid.\n#'                In A. Raeithel (1998). Selbstorganisation, Kooperation, \n#'                Zeichenprozess. Arbeiten zu einer kulturwissenschaftlichen, \n#'                anwendungsbezogenen Psychologie (p. 209-254). Opladen: \n#'                Westdeutscher Verlag.\n#'\n#' @author        Mark Heckmann\n#' @export\n#'\n#' @seealso   Unsophisticated biplot: \\code{\\link{biplotSimple}}; \\cr\n#'            2D biplots:\n#'            \\code{\\link{biplot2d}},\n#'            \\code{\\link{biplotEsa2d}},\n#'            \\code{\\link{biplotSlater2d}};\\cr\n#'            Pseudo 3D biplots:\n#'            \\code{\\link{biplotPseudo3d}},  \n#'            \\code{\\link{biplotEsaPseudo3d}},\n#'            \\code{\\link{biplotSlaterPseudo3d}};\\cr\n#'            Interactive 3D biplots:\n#'            \\code{\\link{biplot3d}},\n#'            \\code{\\link{biplotEsa3d}},\n#'            \\code{\\link{biplotSlater3d}};\\cr\n#'            Function to set view in 3D:\n#'            \\code{\\link{home}}.\n#'\n#' @examples \\dontrun{\n#'    # See examples in \\code{\\link{biplot2d}} as the same arguments\n#'    # can used for this function.\n#' }\n#'\nbiplotEsa2d <- function(x, center=4, g=1, h=1, ...){\n  biplot2d(x=x, center=center, g=g, h=h, ...)\n}\n\n\n#' Plot an eigenstructure analysis (ESA) in 2D grid with 3D \n#' impression (pseudo 3D). \n#'\n#' The ESA is \n#' a special type of biplot suggested by Raeithel (e.g. 1998).\n#' It uses midpoint centering as a default. Note that the eigenstructure analysis\n#' is just a special case of a biplot that can also be produced using the \n#' \\code{\\link{biplot2d}} function with the arguments \n#' \\code{center=4, g=1, h=1}.\n#' Here, only the arguments that are modified for the ESA biplot are described.\n#' To see all the parameters that can be changed see \\code{\\link{biplot2d}}\n#' and \\code{\\link{biplotPseudo3d}}.\n#'\n#' @param x           \\code{repgrid} object.\n#' @param  center\t\t  Numeric. The type of centering to be performed. \n#'                    0= no centering, 1= row mean centering (construct), \n#'                    2= column mean centering (elements), 3= double-centering \n#'                    (construct and element means),\n#'                    4= midpoint centering of rows (constructs).\n#'                    Eigenstructure analyis uses midpoint centering (\\code{4}).\n#' @param g           Power of the singular value matrix assigned to the left singular \n#'                    vectors, i.e. the constructs. Eigenstructure analyis uses  \n#'                    \\code{g=1}.\n#' @param h           Power of the singular value matrix assigned to the right singular \n#'                    vectors, i.e. the elements. Eigenstructure analyis uses  \n#'                    \\code{h=1}.\n#' @param ...         Additional parameters for be passed to \\code{\\link{biplotPseudo3d}}.\n#'\n#' @author            Mark Heckmann\n#' @export\n#'\n#' @seealso   Unsophisticated biplot: \\code{\\link{biplotSimple}}; \\cr\n#'            2D biplots:\n#'            \\code{\\link{biplot2d}},\n#'            \\code{\\link{biplotEsa2d}},\n#'            \\code{\\link{biplotSlater2d}};\\cr\n#'            Pseudo 3D biplots:\n#'            \\code{\\link{biplotPseudo3d}},  \n#'            \\code{\\link{biplotEsaPseudo3d}},\n#'            \\code{\\link{biplotSlaterPseudo3d}};\\cr\n#'            Interactive 3D biplots:\n#'            \\code{\\link{biplot3d}},\n#'            \\code{\\link{biplotEsa3d}},\n#'            \\code{\\link{biplotSlater3d}};\\cr\n#'            Function to set view in 3D:\n#'            \\code{\\link{home}}.\n#'\n#' @examples \\dontrun{\n#'    # See examples in \\code{\\link{biplotPseudo3d}} as the same arguments\n#'    # can used for this function.\n#' }\n#'\nbiplotEsaPseudo3d <- function(x, center=4, g=1, h=1, ...){\n  biplotPseudo3d(x=x, center=center, g=g, h=h, ...)\n}\n\n\n\n\n###############################################################################\n\n# x <- boeker\n# x <- calcBiplotCoords(x, g=1, h=1)\n# x <- prepareBiplotData(x, unity=F)\n# biplot2d(x)\n# \n# biplot2d(x)\n\n\n###############################################################################\n\n\n\n\n",
    "created" : 1388448989881.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "474084352",
    "id" : "EC012386",
    "lastKnownWriteTime" : 1388451308,
    "path" : "~/_mh/programming/R/pkg_dev/grid/OpenRepGrid/OpenRepGrid/R/repgrid-plots.r",
    "project_path" : "R/repgrid-plots.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}