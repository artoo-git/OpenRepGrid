{
    "contents" : "\n#' Descriptive statistics for constructs and elements of a grid.\n#'\n#' @param x       \\code{repgrid} object.\n#' @param index   Whether to print the number of the element. \n#' @param trim    The number of characters an element or a construct\n#'                is trimmed to (default is\n#'                \\code{20}). If \\code{NA} no trimming occurs. Trimming\n#'                simply saves space when displaying correlation of constructs\n#'                or elements with long names.\n#' @return        A dataframe containing the following measures is returned invisibly \n#'                (see \\code{\\link{describe}}): \\cr\n#'                item name \\cr\n#'                item number \\cr \n#'                number of valid cases \\cr  \n#'                mean standard deviation \\cr\n#'                trimmed mean (with trim defaulting to .1) \\cr\n#'                median (standard or interpolated) \\cr\n#'                mad: median absolute deviation (from the median) \\cr\n#'                minimum \\cr\n#'                maximum \\cr\n#'                skew \\cr\n#'                kurtosis \\cr\n#'                standard error \\cr\n#'\n#' @note          Note that standard deviation and variance are estimations, \n#'                i.e. including Bessel's correction. For more info type \\code{?describe}.\n#'\n#' @author        Mark Heckmann\n#' @export\n#' @aliases statsElements statsConstructs \n#' @rdname stats\n#' @examples \\dontrun{\n#'\n#'    statsConstructs(fbb2003)\n#'    statsConstructs(fbb2003, trim=10)\n#'    statsConstructs(fbb2003, trim=10, index=F)\n#'\n#'    statsElements(fbb2003)\n#'    statsElements(fbb2003, trim=10)\n#'    statsElements(fbb2003, trim=10, index=F)\n#'\n#'    # save the access the results\n#'    d <- statsElements(fbb2003)\n#'    d\n#'    d[\"mean\"]\n#'    d[2, \"mean\"]  # mean rating of 2nd element\n#'  \n#'    d <- statsConstructs(fbb2003)\n#'    d\n#'    d[\"sd\"]\n#'    d[1, \"sd\"]   # sd of ratings on first construct\n#' }\n#'\nstatsElements <- function(x, index=TRUE, trim=20)\n{\n  if (!inherits(x, \"repgrid\")) \t\t\t\t\t\t\t      # check if x is repgrid object\n  \tstop(\"Object x must be of class 'repgrid'\")\n  s <- getRatingLayer(x)\n  res <- describe(s)                              # psych function\n  enames <- getElementNames2(x, index=index, trim=trim) \n  ne <- getNoOfElements(x)\n  if (length(unique(enames)) != ne){\n    stop(\"please chose a longer value for 'trim' or set 'index' to TRUE\", \n         \"as the current value produces indentical rownames\")\n  }  \n  rownames(res) <- enames\n  class(res) <- c(\"statsElements\", \"data.frame\")\n  return(res)\n}\n# compare Bell, 1997, p. 7\n\n\n#' Print method for class statsElements\n#' \n#' @param x         Object of class statsElements.\n#' @param digits    Numeric. Number of digits to round to (default is \n#'                  \\code{1}).\n#' @param ...       Not evaluated.\n#' @export\n#' @method          print statsElements\n#' @keywords        internal\n#'\nprint.statsElements <- function(x, digits=2, ...) \n{\n  cat(\"\\n##################################\")\n  cat(\"\\nDesriptive statistics for elements\")\n  cat(\"\\n##################################\\n\\n\")\n  x <- as.data.frame(x)\n  print(round(x, 2))\n}\n\n\n#' Descriptive statistics for constructs and elements of a grid.\n#'\n#' @note          Note that standard deviation and variance are estimated ones, \n#'                i.e. including Bessel's correction. For more info type \\code{?describe}.\n#'\n#' @author        Mark Heckmann\n#' @export\n#' @rdname stats\n#'\nstatsConstructs <- function(x, index=T, trim=20){\n  if (!inherits(x, \"repgrid\")) \t\t\t\t\t\t\t      # check if x is repgrid object\n   \tstop(\"Object x must be of class 'repgrid'\")\n  s <- getRatingLayer(x)\n  res <- describe(t(s))\n  cnames <- getConstructNames2(x, index=index, trim=trim)\n  rownames(res) <- cnames\n  class(res) <- c(\"statsConstructs\", \"data.frame\")\n  return(res)\n}\n# compare Bell, 1997, p. 9\n\n\n#' Print method for class statsConstructs\n#' \n#' @param x         Object of class statsConstructs.\n#' @param digits    Numeric. Number of digits to round to (default is \n#'                  \\code{1}).\n#' @param ...       Not evaluated.\n#' @export\n#' @method          print statsConstructs\n#' @keywords        internal\n#'\nprint.statsConstructs <- function(x, digits=2, ...) \n{\n  cat(\"\\n####################################\")\n  cat(\"\\nDesriptive statistics for constructs\")\n  cat(\"\\n####################################\\n\\n\")\n  x <- as.data.frame(x)\n  print(round(x, 2))\n}\n\n\n# TODO:\n# Golden Section Statistics, p. 10\n# Adams-Webber (1990) for dichotmous data\n# Bell & McGorry for rating grids\n#\n# Adams-Webber, J.R. (1990) Some fundamental asymmetries in the structure of personal\n# constructs. Advances in Personal Constructs, 1, 49-55.\n#\n# Bell, R. C., & McGorry P. (1992) The analysis of repertory \n# grids used to monitor the perceptions of recovering psychotic \n# patients. In A. Thomson & P. Cummins (Eds) European \n# Perspectives in Personal Construct Psychology. Lincoln UK: \n# European Personal Construct Association.\n# --> ask Richard for paper\n# statsGoldenSection\n\n\ngetScoreDataFrame <- function(x){\n  sc <- x@ratings[,,1]\n  rownames(sc) <- getConstructNames(x)$l\n  colnames(sc) <- getElementNames(x)\n  sc\n}\n\n# disc    element to be used as discrepancy\n# remove  logical. remove element that was used as discrepancy\n#\nmakeDiscrepancy <- function(x, disc, remove=TRUE){\n  sc <- x@ratings[,,1]\n  colnames(sc) <- getElementNames(x)\n  scDiscElement <- sc[, disc]\n  if (remove)\n    sc[, -disc] - scDiscElement else \n    sc[,] - scDiscElement\n}\n\nstatsDiscrepancy <- function(x, disc, sort=TRUE){\n  a <- describe(makeDiscrepancy(x, disc))\n  if (sort)\n    a[order(a$mean),] else\n    a \n}\n\n\n\n# Measures comparing Constructs: Intensity, Cognitive Complexity \n# and other measures of Grid variation.\n\n# Ward Hierarchical Clustering\n# cluster <- function(){\n#   \n#   \n# }\n# a <- doubleEntry(x)\n# sc <- getScoreDataFrame(x)\n# d <- dist(sc, method = \"euclidean\") # distance matrix\n# fit <- hclust(d, method=\"ward\")\n# plot(as.dendrogram(fit), horiz = F)\n# plot(as.dendrogram(fit), horiz = F)\n\n\n###############################################################################\n# order elements and constructs by angles in first two dimensions from\n# singular value decomposition approach (cf. Raeithel ???)\n###############################################################################\n\n#' Calculate angles for points in first two columns.\n#'\n#' The angles of the points given by the values in the first and second\n#' column of a matrix seen from the origin are calulated in degrees.\n#'\n#' @param x           A matrix.\n#' @param dim         Dimensions used for calculating angles.\n#' @param clockwise   Logical. Positive angles are clockwise with x axis as \n#'                    basis.\n#' @return  vector.   The angles of each row point with the origin as reference.\n#'\n#' @author       Mark Heckmann\n#' @keywords internal\n#'\n#' @examples \\dontrun{\n#'\n#'    calcAngles(matrix(rnorm(9), 3))\n#' }\n#'\ncalcAngles <- function(x, dim=c(1,2), clockwise=TRUE){\n  angles <- atan2(x[ ,dim[2]], x[ ,dim[1]]) / (2 * pi / 360)\n  angles <- angles * -1                    # positive angles are counted clockwise atan2 does anticlockwise by default\n  angles[angles < 0] <- 360 + angles[angles < 0]  # map to 0 to 360 degrees i.e. only positive  values for ordering\n  if (!clockwise)\n    angles <- 360 - angles\n  angles\n}\n\n\n#' Make indexes to order grid by angles in given dimensions.\n#'\n#' Reorder indexes for constructs and elements are calculated \n#' using the coordinates of the given dimensions.\n#'\n#' @param x           \\code{repgrid} object that has been submitted to\n#'                    \\code{\\link{calcBiplotCoords}}.\n#' @param dim         Dimensions used to calculate angles for reordering grid.\n#' @param clockwise   Logical. Positive angles are clockwise with x axis as \n#'                    basis.\n#' @return  A list containing the indexes to reorder the grid. The \n#'          first list element for the constructs, the second for the elements indexes.\n#'\n#' @author        Mark Heckmann\n#' @keywords internal\n#' @examples \\dontrun{\n#'\n#'    x <- randomGrid(15,30)      # make random grid\n#'    i <- angleOrderIndexes2d(x) # make indexes for ordering\n#'    x <- x[i[[1]], i[[2]]]      # reorder constructs and elements\n#'    x                           # print grid\n#' }\n#'                  \nangleOrderIndexes2d <- function(x, dim=c(1,2), clockwise=TRUE){\n  if (!inherits(x, \"repgrid\")) \t\t\t\t\t\t\t      # check if x is repgrid object\n  \tstop(\"Object x must be of class 'repgrid'\") \n  E.mat <- x@calcs$biplot$elem\n  C.mat <- x@calcs$biplot$con\n  C.angles <- calcAngles(C.mat, dim=dim, clockwise=clockwise)\n  E.angles <- calcAngles(E.mat, dim=dim, clockwise=clockwise)\n  list(c.order=order(C.angles), \n       e.order=order(E.angles))\n}\n\n\n#' Order grid by angles between construct and/or elements in 2D.\n#'\n#' The approach is to reorder \n#' the grid matrix by their polar angles on the first two principal \n#' components from a data reduction technique \n#' (here the biplot, i.e. SVD). The function \n#' \\code{reorder2d} reorders the grid according to the angles \n#' between the x-axis and the element (construct) \n#' vectors derived from a 2D biplot solution.\n#' This approach is apt to identify circumplex \n#' structures in data indicated by the diagonal stripe \n#' in the display (see examples).\n#'\n#' @param x           \\code{repgrid} object.\n#' @param dim         Dimension of 2D solution used to calculate angles\n#'                    (default \\code{c(1,2)}).\n#' @param center\t\t  Numeric. The type of centering to be performed. \n#'                    0= no centering, 1= row mean centering (construct), \n#'                    2= column mean centering (elements), 3= double-centering (construct and element means),\n#'                    4= midpoint centering of rows (constructs).\n#'                    The default is \\code{1} (row centering).\n#' @param normalize   A numeric value indicating along what direction (rows, columns)\n#'                    to normalize by standard deviations. \\code{0 = none, 1= rows, 2 = columns}\n#'                    (default is \\code{0}).\n#' @param g           Power of the singular value matrix assigned to the left singular \n#'                    vectors, i.e. the constructs.\n#' @param h           Power of the singular value matrix assigned to the right singular \n#'                    vectors, i.e. the elements.\n#' @param rc          Logical. Reorder constructs by similarity (default \\code{TRUE}).\n#' @param re          Logical. Reorder elements by similarity (default \\code{TRUE}).\n#' @param ...         Not evaluated.\n#'\n#' @return            Reordered \\code{repgrid} object. \n#'\n#' @author            Mark Heckmann\n#' @export\n#'\n#' @examples \\dontrun{\n#'\n#'    x <- feixas2004  \n#'    reorder2d(x)            # reorder grid by angles in first two dimensions\n#'    reorder2d(x, rc=F)      # reorder elements only\n#'    reorder2d(x, re=F)      # reorder constructs only\n#' }\n#'\nreorder2d <- function(x, dim=c(1,2), center=1, normalize=0, g=0, h=1-g, \n                    rc=TRUE, re=TRUE, ... ){\n  if (!inherits(x, \"repgrid\")) \t\t\t\t\t\t\t  # check if x is repgrid object\n  \tstop(\"Object x must be of class 'repgrid'\")\n  x <- calcBiplotCoords(x, center=center, normalize=normalize, g=g, h=h, ...)\n  i <- angleOrderIndexes2d(x, dim=dim)        # make indexes for ordering\n  if(rc)\n    x <- x[i[[1]], ,drop=FALSE]\n  if(re)\n    x <- x[ ,i[[2]], drop=FALSE]\n  x\n}\n\n\n\n  \n  \n  \n###############################################################################\n\n\n#' Calculate the correlations between elements.\n#' \n#' Note that simple element correlations as a measure of similarity\n#' are flawed as they are not invariant to construct reflection (Mackay, 1992; \n#' Bell, 2010). A correlation index invariant to construct reflection is \n#' Cohen's rc measure (1969), which can be calculated using the argument \n#' \\code{rc=TRUE} which is the default option.\n#'\n#' @param x         \\code{repgrid} object.\n#' @param rc        Use Cohen's rc which is invariant to construct \n#'                  reflection (see desciption above). It is used as the default.\n#' @param method    A character string indicating which correlation coefficient \n#'                  is to be computed. One of \\code{\"pearson\"} (default), \n#'                  \\code{\"kendall\"} or \\code{\"spearman\"}, can be abbreviated.\n#'                  The default is \\code{\"pearson\"}.\n#' @param trim      The number of characters a construct is trimmed to (default is\n#'                  \\code{20}). If \\code{NA} no trimming occurs. Trimming\n#'                  simply saves space when displaying correlation of constructs\n#'                  with long names.\n#' @param index     Whether to print the number of the construct. \n#'\n#' @references      Bell, R. C. (2010). A note on aligning constructs. \n#'                  \\emph{Personal Construct Theory & Practice}, (7), 42-48.\n#'\n#'                  Cohen, J. (1969). rc: A profile similarity coefficient \n#'                  invariant over variable reflection. \\emph{Psychological \n#'                  Bulletin, 71}(4), 281-284.\n#'\n#'                  Mackay, N. (1992). Identification, Reflection, \n#'                  and Correlation: Problems In The Bases Of Repertory \n#'                  Grid Measures. \\emph{International Journal of Personal\n#'                  Construct Psychology, 5}(1), 57-75. \n#'\n#' @return  \\code{matrix} of element correlations\n#'\n#' @author        Mark Heckmann\n#' @export\n#' @seealso \\code{\\link{constructCor}}\n#'\n#' @examples\n#'\n#'    elementCor(mackay1992)                      # Cohen's rc\n#'    elementCor(mackay1992, rc=FALSE)            # PM correlation\n#'    elementCor(mackay1992, rc=FALSE, method=\"spearman\")  # Spearman correlation\n#'\n#'    # format output\n#'    elementCor(mackay1992, trim=6)\n#'    elementCor(mackay1992, index=FALSE, trim=6)\n#'\n#'    # save as object for further processing\n#'    r <- elementCor(mackay1992)\n#'    r\n#'    \n#'    # change output of object\n#'    print(r, digits=5)\n#'    print(r, col.index=FALSE)\n#'    print(r, upper=FALSE)\n#'    \n#'    # accessing elements of the correlation matrix\n#'    r[1,3]\n#'    \nelementCor <- function(x, rc=TRUE, method=\"pearson\", \n                          trim=20, index=TRUE)\n{\n  method <- match.arg(method,  c(\"pearson\", \"kendall\", \"spearman\"))\n  if (!inherits(x, \"repgrid\")) \t\t\t\t\t\t\t# check if x is repgrid object\n  \tstop(\"Object x must be of class 'repgrid'\")\n  if (rc) {\n    x <- doubleEntry(x)                     # double entry to get rc correlation\n    method <- \"pearson\"                     # Cohen's rc is only defined for pearson correlation\n  }\n  scores <- getRatingLayer(x)\n  res <- cor(scores, method=method)\n  res <- addNamesToMatrix2(x, res, index=index, trim=trim, along=2)\n  class(res) <- c(\"elementCor\", \"matrix\")\n  attr(res, \"arguments\") <- list(method=method, rc=rc)\n  res\n}\n\n\n#' Print method for class elementCor.\n#' \n#' @param x           Object of class elementCor\n#' @param digits      Numeric. Number of digits to round to (default is \n#'                    \\code{2}).\n#' @param col.index   Logical. Whether to add an extra index column so the \n#'                    column names are indexes instead of construct names. This option \n#'                    renders a neater output as long construct names will stretch \n#'                    the output (default is \\code{TRUE}).\n#' @param upper       Whether to display upper triangle of correlation matrix only \n#'                    (default is \\code{TRUE}).\n#' @param ...         Not evaluated.\n#' @export\n#' @method            print elementCor\n#' @keywords          internal\n#'\nprint.elementCor <- function(x, digits=2, col.index=TRUE, upper=TRUE, ...)\n{\n  args <- attr(x, \"arguments\")\n  class(x) <- \"matrix\"\n  x <- round(x, digits)\n  d <- format(x, nsmall=digits)\n  \n  # console output\n  if (upper)\n    d[lower.tri(d, diag=TRUE)] <- paste(rep(\" \", digits + 1), collapse=\"\", sep=\"\")\n  if (col.index)                                   # make index column for neater colnames\n    d <- addIndexColumnToMatrix(d) \n  d <- as.data.frame(d)\n  cat(\"\\n############################\")\n  cat(\"\\nCorrelation between elements\")\n  cat(\"\\n############################\")\n  if (args$rc)\n    args$method <- \"Cohens's rc (invariant to scale reflection)\"\n  cat(\"\\n\\nType of correlation: \", args$method, \"\\n\")\n  if (!args$rc)\n    cat(\"Note: Standard correlations are not invariant to scale reflection.\\n\")\n  cat(\"\\n\")\n  print(d)\n}\n\n\n#' Root mean square (RMS) of inter-element correlations.\n#'\n#' The RMS is also known as 'quadratic mean' of \n#' the inter-element correlations. The RMS serves as a simplification of the \n#' correlation table. It reflects the average relation of one element with all \n#' other elements. Note that as the correlations are squared during its calculation, \n#' the RMS is not affected by the sign of the correlation (cf. Fransella, \n#' Bell & Bannister, 2003, p. 86).\n#' \n#' Note that simple element correlations as a measure of similarity\n#' are flawed as they are not invariant to construct reflection (Mackay, 1992; \n#' Bell, 2010). A correlation index invariant to construct reflection is \n#' Cohen's rc measure (1969), which can be calculated using the argument \n#' \\code{rc=TRUE} which is the default option in this function.\n#'                  \n#' @param x       \\code{repgrid} object.\n#' @param rc      Whether to use Cohen's rc which is invariant to construct \n#'                reflection (see desciption above). It is used as the default.\n#' @param method  A character string indicating which correlation coefficient \n#'                to be computed. One of \\code{\"pearson\"} (default), \n#'                \\code{\"kendall\"} or \\code{\"spearman\"}, can be abbreviated.\n#'                The default is \\code{\"pearson\"}.\n#' @param trim    The number of characters an element is trimmed to (default is\n#'                \\code{NA}). If \\code{NA} no trimming occurs. Trimming\n#'                simply saves space when displaying correlation of constructs\n#'                with long names.\n#' @return        \\code{dataframe} of the RMS of inter-element correlations\n#'\n#' @author        Mark Heckmann\n#' @export\n#' @seealso  \\code{\\link{constructRmsCor}}, \\code{\\link{elementCor}}\n#'\n#' @references    Fransella, F., Bell, R. C., & Bannister, D. (2003). \n#'                A Manual for Repertory \n#'                Grid Technique (2. Ed.). Chichester: John Wiley & Sons.\n#'\n#' @examples \n#'\n#'    # data from grid manual by Fransella, Bell and Bannister\n#'    elementRmsCor(fbb2003)    \n#'    elementRmsCor(fbb2003, trim=10)\n#'    \n#'    # modify output\n#'    r <- elementRmsCor(fbb2003) \n#'    print(r, digits=5)\n#'\n#'    # access second row of calculation results\n#'    r[2, \"RMS\"]\n#'\nelementRmsCor <- function(x, rc = TRUE, method = \"pearson\", trim = NA)\n{\n  method <- match.arg(method,  c(\"pearson\", \"kendall\", \"spearman\"))\n  res <- elementCor(x, rc = rc, method = method, trim = trim,\n             index = TRUE)                              # calc correlations \n  diag(res) <- NA                                       # remove diagonal \n  res <- apply(res^2, 1, mean, na.rm=TRUE)              # mean of squared values \n  res <- data.frame(RMS = res^.5)                       # root of mean squares\n  class(res) <- c(\"rmsCor\", \"data.frame\")\n  attr(res, \"type\") <- \"elements\"\n  return(res)\n}\n\n\n###############################################################################\n\n#' Calculate correlations between constructs. \n#'\n#' Different types of correlations can be requested: \n#' PMC, Kendall tau rank correlation, Spearman rank correlation.\n#'\n#' @param x         \\code{repgrid} object.\n#' @param method    A character string indicating which correlation coefficient \n#'                  is to be computed. One of \\code{\"pearson\"} (default), \n#'                  \\code{\"kendall\"} or \\code{\"spearman\"}, can be abbreviated.\n#'                  The default is \\code{\"pearson\"}.\n#' @param trim      The number of characters a construct is trimmed to (default is\n#'                  \\code{20}). If \\code{NA} no trimming occurs. Trimming\n#'                  simply saves space when displaying correlation of constructs\n#'                  with long names.\n#' @param index     Whether to print the number of the construct. \n#' @return          Returns a matrix of construct correlations.\n#'\n#' @author          Mark Heckmann\n#' @export\n#' @seealso \\code{\\link{elementCor}}\n#'\n#' @examples \n#'\n#'    # three different types of correlations\n#'    constructCor(mackay1992)                \n#'    constructCor(mackay1992, method=\"kendall\")\n#'    constructCor(mackay1992, method=\"spearman\")\n#'\n#'    # format output\n#'    constructCor(mackay1992, trim=6)\n#'    constructCor(mackay1992, index=TRUE, trim=6)\n#'    \n#'    # save correlation matrix for further processing\n#'    r <- constructCor(mackay1992)\n#'    r\n#'    print(r, digits=5)\n#'    \n#'    # accessing the correlation matrix\n#'    r[1, 3]\n#'\nconstructCor <- function(x, method = c(\"pearson\", \"kendall\", \"spearman\"), \n                         trim=20, index=FALSE){\n  if (!inherits(x, \"repgrid\")) \t\t\t\t\t\t\t      # check if x is repgrid object\n  \tstop(\"Object x must be of class 'repgrid'\")\n  method <- match.arg(method)\n  scores <- getRatingLayer(x)\n  res <- cor(t(scores), method=method)\n  res <- addNamesToMatrix2(x, res, index=index, trim=trim)\n  class(res) <- c(\"constructCor\", \"matrix\") \n  attr(res, \"arguments\") <- list(method=method)  \n  return(res)\n}\n\n\n#' Print method for class constructCor.\n#' \n#' @param x           Object of class constructCor.\n#' @param digits      Numeric. Number of digits to round to (default is \n#'                    \\code{2}).\n#' @param col.index   Logical. Whether to add an extra index column so the \n#'                    column names are indexes instead of construct names. This option \n#'                    renders a neater output as long construct names will stretch \n#'                    the output (default is \\code{TRUE}).\n#' @param upper       Whether to display upper triangle of correlation matrix only \n#'                    (default is \\code{TRUE}).\n#' @param header      Whether to print additional information in header.\n#' @param ...         Not evaluated.\n#' @export\n#' @method            print constructCor\n#' @keywords          internal\n#'\nprint.constructCor <- function(x, digits=2, col.index=TRUE,\n                               upper=TRUE, header=TRUE, ...)\n{\n  args <- attr(x, \"arguments\")\n  d <- x\n  class(d) <- \"matrix\"\n  d <- round(d, digits) \n  d <- format(d, nsmall=digits)\n  if (upper)\n    d[lower.tri(d, diag=TRUE)] <- paste(rep(\" \", digits + 1), collapse=\"\", sep=\"\")\n  if (col.index)                                   # make index column for neater colnames\n    d <- addIndexColumnToMatrix(d) else\n      colnames(d) <- seq_len(ncol(d))\n  d <- as.data.frame(d)\n  if (header) {\n    cat(\"\\n##############################\")\n    cat(\"\\nCorrelation between constructs\")\n    cat(\"\\n##############################\")\n    cat(\"\\n\\nType of correlation: \", args$method, \"\\n\\n\")\n  }\n  print(d)\n}\n\n\n\n#' Root mean square (RMS) of inter-construct correlations.\n#'\n#' The RMS is also known as 'quadratic mean' of \n#' the inter-construct correlations. The RMS serves as a simplification of the \n#' correlation table. It reflects the average relation of one construct to all \n#' other constructs. Note that as the correlations are squared during its calculation, \n#' the RMS is not affected by the sign of the correlation (cf. Fransella, \n#' Bell & Bannister, 2003, p. 86).\n#'\n#' @param x       \\code{repgrid} object\n#' @param method  A character string indicating which correlation coefficient \n#'                is to be computed. One of \\code{\"pearson\"} (default), \n#'                \\code{\"kendall\"} or \\code{\"spearman\"}, can be abbreviated.\n#'                The default is \\code{\"pearson\"}.\n#' @param trim    The number of characters a construct is trimmed to (default is\n#'                \\code{NA}). If \\code{NA} no trimming occurs. Trimming\n#'                simply saves space when displaying correlation of constructs\n#'                with long names.\n#' @return        \\code{dataframe} of the RMS of inter-construct correlations\n#'\n#' @author        Mark Heckmann\n#' @export\n#' @seealso    \\code{\\link{elementRmsCor}}, \\code{\\link{constructCor}}\n#'\n#' @references    Fransella, F., Bell, R. C., & Bannister, D. (2003). \n#'                A Manual for Repertory \n#'                Grid Technique (2. Ed.). Chichester: John Wiley & Sons.\n#'\n#' @examples \n#'\n#'    # data from grid manual by Fransella, Bell and Bannister\n#'    constructRmsCor(fbb2003)    \n#'    constructRmsCor(fbb2003, trim=20)\n#'    \n#'    # modify output\n#'    r <- constructRmsCor(fbb2003) \n#'    print(r, digits=5)\n\n#'    # access calculation results\n#'    r[2, 1]\n#'\nconstructRmsCor <- function(x, method = \"pearson\", trim = NA)\n{\n  method <- match.arg(method,  c(\"pearson\", \"kendall\", \"spearman\"))\n  res <- constructCor(x, method = method, trim=trim, \n                      index=TRUE)                       # calc correlations\n  diag(res) <- NA                                       # remove diagonal \n  res <- apply(res^2, 1, mean, na.rm=TRUE)              # mean of squared values\n  res <- data.frame(RMS = res^.5)                       # root of mean squares\n  class(res) <- c(\"rmsCor\", \"data.frame\")\n  attr(res, \"type\") <- \"constructs\" \n  return(res)\n}\n\n\n#' Print method for class rmsCor (RMS correlation for constructs or elements)\n#' \n#' @param x           Object of class rmsCor.\n#' @param digits      Numeric. Number of digits to round to (default is \n#'                    \\code{2}).\n#' @param ...         Not evaluated.\n#' @export\n#' @method            print rmsCor\n#' @keywords          internal\n#'\nprint.rmsCor <- function(x, digits=2, ...)\n{\n  d <- as.data.frame(x)\n  d <- round(d, digits)  \n  type <- attr(x, \"type\")\n  cat(\"\\n##########################################\")\n  cat(\"\\nRoot-mean-square correlation of\", type)\n  cat(\"\\n##########################################\\n\\n\")\n  print(d) \n  cat(\"\\nAverage of statistic\", round(mean(unlist(d), na.rm=TRUE), digits), \"\\n\")\n  cat(\"Standard deviation of statistic\", round(sdpop(d, na.rm=TRUE), digits), \"\\n\")\n}\n\n\n#' Calculate Somers' d for the constructs. \n#'\n#' Somer'ss d is an  assymetric association measure as it depends on which \n#' variable is set as dependent and independent.\n#' The direction of dependency needs to be specified.\n#'\n#' @param x           \\code{repgrid} object\n#' @param dependent   A string denoting the direction of dependency in the output \n#'                    table (as d is assymetrical). Possible values are \\code{\"columns\"}\n#'                    (the default) for setting the columns as dependent, \\code{\"rows\"} \n#'                    for setting the rows as the dependent variable and \n#'                    \\code{\"symmetric\"} for the \n#'                    symmetrical Somers' d measure (the mean of the two directional \n#'                    values for code{\"columns\"} and \\code{\"rows\"}).\n#' @param trim        The number of characters a construct is trimmed to (default is\n#'                    \\code{30}). If \\code{NA} no trimming occurs. Trimming\n#'                    simply saves space when displaying correlation of constructs\n#'                    with long names.\n#' @param index       Whether to print the number of the construct \n#'                    (default is \\code{TRUE}). \n#' @return            \\code{matrix} of construct correlations.\n#' @note              Thanks to Marc Schwartz for supplying the code to calculate\n#'                    Somers' d.\n#' @references        Somers, R. H. (1962). A New Asymmetric Measure of Association\n#'                    for Ordinal Variables. \\emph{American Sociological Review, 27}(6),\n#'                    799-811.\n#'\n#' @author            Mark Heckmann\n#' @export\n#'\n#' @examples \\dontrun{\n#'\n#'    constructD(fbb2003)       # columns as dependent (default)\n#'    constructD(fbb2003, \"c\")  # row as dependent\n#'    constructD(fbb2003, \"s\")  # symmetrical index\n#'  \n#'    # surpress printing\n#'    d <- constructD(fbb2003, out=0, trim=5)\n#'    d\n#'    \n#'    # more digits\n#'    constructD(fbb2003, dig=3)\n#'\n#'    # add index column, no trimming\n#'    constructD(fbb2003, col.index=TRUE, index=F, trim=NA)  \n#'\n#' }\n#'\nconstructD <- function(x, dependent = \"columns\", trim=30, index=TRUE)\n{\n  if (!inherits(x, \"repgrid\")) \t\t\t\t\t\t\t    # check if x is repgrid object\n  \tstop(\"Object x must be of class 'repgrid'\")\n  dependent <- match.arg(dependent, c(\"columns\", \"rows\", \"symmetric\")) \n  scores <- getRatingLayer(x)\n  l <- lapply(as.data.frame(t(scores)),  I)     # put each row into a list\n    \n  somersd <- function(x, y, dependent, smin, smax){\n    na.index <- is.na(x) | is.na(y)\n    x <- x[!na.index]\n    y <- y[!na.index]\n    x <- factor(unlist(x), levels=seq(smin, smax))\n    y <- factor(unlist(y), levels=seq(smin, smax))\n    m <-  as.matrix(table(x,y))\n    \n    if (dependent == \"rows\")\n      i <- 1 else \n    if (dependent == \"columns\")\n      i <- 2 else \n    if (dependent == \"symmetric\")\n      i <- 3\n    calc.Sd(m)[[i]]\n  }  \n  \n  nc <- length(l)\n  smin <- x@scale$min\n  smax <- x@scale$max\n  sds <- mapply(somersd, rep(l,each=nc), rep(l, nc), \n                MoreArgs=list(dependent=dependent, \n                              smin=smin, smax=smax))\n  res <- matrix(sds, nc)\n  res <- addNamesToMatrix2(x, res, index=index, trim=trim, along=1)\n  class(res) <- c(\"constructD\", \"matrix\")\n  attr(res, \"arguments\") <- list(dependent=dependent)\n  res\n}\n\n\n#' Print method for class constructD.\n#' \n#' @param x           Object of class constructD.\n#' @param digits      Numeric. Number of digits to round to (default is \n#'                    \\code{2}).\n#' @param col.index   Logical. Whether to add an extra index column so the \n#'                    column names are indexes instead of construct names. This option \n#'                    renders a neater output as long construct names will stretch \n#'                    the output (default is \\code{TRUE}).\n#' @param ...         Not evaluated.\n#' @export\n#' @method            print constructD\n#' @keywords          internal\n#'\nprint.constructD <- function(x, digits=1, col.index=TRUE, ...)\n{\n  class(x) <- \"matrix\"\n  x <- round(x, digits)\n  args <- attr(x, \"arguments\")\n  attr(x, \"arguments\") <- NULL\n  cat(\"\\n############################\")\n  cat(\"\\nSomers' D between constructs\")\n  cat(\"\\n############################\\n\\n\")\n  cat(\"Direction:\", args$dependent, \"are set as dependent\\n\")\n  if (col.index)                                  # make index column for neater colnames\n    x <- addIndexColumnToMatrix(x) else\n      colnames(x) <- seq_len(ncol(x))\n  print(x)\n}\n\n\n#' Principal component analysis (PCA) of inter-construct correlations.\n#'\n#' Various methods for rotation and methods for the calculation of the \n#' correlations are available. Note that the number of factors\n#' has to be specified. For more information on the PCA function itself type \n#' \\code{?principal}. \n#'\n#' @param x           \\code{repgrid} object.\n#' @param nfactors    Number of components to extract (default is \\code{3}).\n#' @param rotate      \\code{\"none\"}, \\code{\"varimax\"}, \\code{\"promax\"} and \\code{\"cluster\"} \n#'                    are possible rotations (default is \\code{none}).\n#' @param method      A character string indicating which correlation coefficient \n#'                    is to be computed. One of \\code{\"pearson\"} (default), \n#'                    \\code{\"kendall\"} or \\code{\"spearman\"}, can be abbreviated.\n#'                    The default is \\code{\"pearson\"}.\n#' @param trim        The number of characters a construct is trimmed to (default is\n#'                    \\code{7}). If \\code{NA} no trimming occurs. Trimming\n#'                    simply saves space when displaying correlation of constructs\n#'                    with long names.\n#' @return            Returns an object of class \\code{constructPca}.\n#'\n#' @seealso           To extract the PCA loadings for further processing see\n#'                    \\code{\\link{constructPcaLoadings}}.\n#' @author            Mark Heckmann\n#' @export\n#' \n#' @references        Fransella, F., Bell, R. & Bannister, D. (2003). \\emph{A Manual for Repertory \n#'                    Grid Technique} (2. Ed.). Chichester: John Wiley & Sons.\n#'\n#' @examples \\dontrun{\n#'\n#'    constructPca(bell2010)\n#'    \n#'    # data from grid manual by Fransella et al. (2003, p. 87)\n#'    # note that the construct order is different\n#'    constructPca(fbb2003, nfactors=2)\n#'\n#'    # no rotation\n#'    constructPca(fbb2003, rotate=\"none\")\n#'    \n#'    # use a different type of correlation (Spearman)\n#'    constructPca(fbb2003, method=\"spearman\")\n#'    \n#'    # save output to object           \n#'    m <- constructPca(fbb2003, nfactors=2)\n#'    m\n#'    \n#'    # different printing options\n#'    print(m, digits=5)\n#'    print(m, cutoff=.3)\n#'    \n#' }\n#'\nconstructPca <- function(x, nfactors=3, rotate=\"varimax\", method = \"pearson\" , \n                         trim=NA) {\n  \n  method <- match.arg(method,c(\"pearson\", \"kendall\", \"spearman\")) \n  rotate <- match.arg(rotate, c(\"none\", \"varimax\", \"promax\", \"cluster\"))\n  if (!rotate %in% c(\"none\", \"varimax\", \"promax\", \"cluster\"))\n    stop('only \"none\", \"varimax\", \"promax\" and \"cluster\" are possible rotations')\n  \n  res <- constructCor(x, method=method, trim=trim)          # calc inter constructs correations                    \n  pc <- principal(res, nfactors = nfactors, rotate=rotate)  # do PCA\n  class(pc) <- c(\"constructPca\", class(pc))\n  attr(pc, \"arguments\") <- list(nfactors=nfactors, rotate=rotate, method=method)\n  return(pc)\n}\n\n\n#' Extract loadings from PCA of constructs.\n#' \n#' @param x       \\code{repgrid} object. This object is returned by the \n#'                function \\code{\\link{constructPca}}.\n#' @return        A matrix containing the factor loadings.\n#' @export\n#' @examples \n#'  \n#'  p <- constructPca(bell2010)\n#'  l <- constructPcaLoadings(p)\n#'  l[1, ]\n#'  l[, 1]\n#'  l[1,1]\n#'  \nconstructPcaLoadings <- function(x)\n{\n  if (!inherits(x, \"constructPca\"))\n    stop(\"'x' must be an object of class 'constructPca'\",\n         \"as returned by the function 'constructPca'\")\n  loadings(x)  \n} \n\n\n#' Print method for class constructPca.\n#' \n#' @param x           Object of class constructPca.\n#' @param digits      Numeric. Number of digits to round to (default is \n#'                    \\code{2}).\n#' @param cutoff      Loadings smaller than cutoff are not printed.\n#' @param ...         Not evaluated.\n#' @export\n#' @method            print constructPca\n#' @keywords          internal\n#'\nprint.constructPca <- function(x, digits=2, cutoff=0, ...)\n{\n  args <- attr(x, \"arguments\")\n  \n  cat(\"\\n#################\")\n  cat(\"\\nPCA of constructs\")\n  cat(\"\\n#################\\n\")\n  \n  cat(\"\\nNumber of components extracted:\", args$nfactors)\n  cat(\"\\nType of rotation:\", args$rotate, \"\\n\")\n  print(loadings(x), cutoff=cutoff, digits=digits)  \n}\n\n\n#' Align constructs by loadings on first pricipal component. \n#'\n#' In case a construct loads negatively on the first principal\n#' component, the function \\code{\\link{alignByLoadings}} will reverse it \n#' so that all constructs have positive loadings on the first \n#' principal component (see deatil section for more).\n#'\n#' The direction of the constructs in a grid is arbitrary and \n#' a reflection of a scale does not affect the information \n#' contained in the grid. Nonetheless, the direction of a scale \n#' has an effect on inter-element correlations (Mackay, 1992) \n#' and on the spatial representation and clustering of the grid \n#' (Bell, 2010). Hence, it is desirable to follow a protocol to align \n#' constructs that will render unique results. A common approach \n#' is to align constructs by pole preference, but this information \n#' is not always accessible. Bell (2010) proposed another solution for\n#'  the problem of construct \n#' alignment. As a unique protocol he suggests to align constructs \n#' in a way so they all have positive loadings on the first \n#' component of a grid PCA.\n#'\n#' @param x         \\code{repgrid} object.\n#' @param trim      The number of characters a construct is trimmed to (default is\n#'                  \\code{10}). If \\code{NA} no trimming is done. Trimming\n#'                  simply saves space when displaying the output.\n#' @param index     Whether to print the number of the construct (e.g. for correltion \n#'                  matrices). The default is \\code{TRUE}.\n#' @return          An object of class \\code{alignByLoadings} containing a list \n#'                  of calculations with the following entries:\n#'                  \n#'                   \\item{cor.before}{Construct correlation matrix before reversal}\n#'                   \\item{loadings.before}{Loadings on PCs before reversal}\n#'                   \\item{reversed}{Constructs that have been reversed}\n#'                   \\item{cor.after}{Construct correlation matrix after reversal}\n#'                   \\item{loadings.after}{Loadings on PCs after reversal}\n#' \n#' @note            Bell (2010) proposed a solution for the problem of construct \n#'                  alignment. As construct reversal has an effect on element \n#'                  correlation and thus on any measure that based on element \n#'                  correlation (Mackay, 1992), it is desireable to have a \n#'                  standard method for \n#'                  construct alignment independently from its semantics (preferred \n#'                  pole etc.). Bell (2010) proposes to align constructs in a way\n#'                  so they all have positive loadings on the first component of a \n#'                  grid PCA.\n#' \n#' @references      Bell, R. C. (2010). A note on aligning constructs.\n#'                  \\emph{Personal Construct Theory & Practice, 7}, 42-48.\n#' \n#'                  Mackay, N. (1992). Identification, Reflection, \n#'                  and Correlation: Problems in ihe bases of repertory \n#'                  grid measures. \\emph{International Journal of Personal\n#'                  Construct Psychology, 5}(1), 57-75. \n#'\n#' @author          Mark Heckmann\n#' @export\n#'\n#' @seealso \\code{\\link{alignByIdeal}}\n#'\n#' @examples \n#'\n#'   # reproduction of the example in the Bell (2010)\n#'   # constructs aligned by loadings on PC 1\n#'   bell2010                    \n#'   alignByLoadings(bell2010)   \n#'\n#'   # save results\n#'   a <- alignByLoadings(bell2010)\n#'   \n#'   # modify printing of resukts\n#'   print(a, digits=5)\n#'   \n#'   # access results for further processing  \n#'   names(a)\n#'   a$cor.before\n#'   a$loadings.before\n#'   a$reversed\n#'   a$cor.after\n#'   a$loadings.after\n#'\nalignByLoadings <- function(x, trim=20, index=TRUE){\n  options(warn=1)                                      # surpress warnings (TODO sometimes error in SVD due to singularities in grid)\n  ccor.old <- constructCor(x, trim=trim, index=index)  # construct correlation unreversed\n  pc.old <- principal(ccor.old)                        # calc principal component (psych pkg)\n  reverseIndex <- \n    which(pc.old$loadings[ ,1] < 0)                    # which constructs to reverse\n  x2 <- swapPoles(x, reverseIndex)                     # reverse constructs\n  ccor.new <- constructCor(x2, trim=trim, index=index) # correlation with reversed constructs\n  pc.new <- principal(ccor.new)                        # 2nd principal comps\n  options(warn=0)                                      # reset to do warnings\n  \n  res <- list(cor.before=ccor.old, \n              loadings.before=pc.old$loadings[ , 1, drop=FALSE],\n              reversed=data.frame(index=reverseIndex),\n              cor.after=ccor.new,\n              loadings.after=pc.new$loadings[ , 1, drop=FALSE])\n  class(res) <- \"alignByLoadings\"\n  res\n}\n\n\n#' Print method for class alignByLoadings.\n#' \n#' @param x           Object of class alignByLoadings.\n#' @param digits      Numeric. Number of digits to round to (default is \n#'                    \\code{2}).\n#' @param col.index   Logical. Whether to add an extra index column so the \n#'                    column names are indexes instead of construct names (e.g. for \n#'                    the correlation matrices). This option \n#'                    renders a neater output as long construct names will stretch \n#'                    the output (default is \\code{TRUE}).\n#' @param ...         Not evaluated.\n#' @export\n#' @method            print alignByLoadings\n#' @keywords          internal\n#'\nprint.alignByLoadings <- function(x, digits=2, col.index=TRUE, ...)\n{\n    cat(\"\\n###################################\")\n    cat(\"\\nAlignment of constructs by loadings\")\n    cat(\"\\n###################################\\n\")\n    \n    cat(\"\\nConstruct correlations - before alignment\\n\\n\")\n    print(x$cor.before, digits=digits, col.index=col.index, header=FALSE)\n    \n    cat(\"\\nConstruct factor loadiongs on PC1 - before alignment\\n\\n\")\n    print(x$loadings.before, digits=digits)\n    \n    cat(\"\\nThe following constructs are reversed:\\n\\n\")\n    if (dim(x$reversed)[1] == 0) {\n      cat(\"None. All constructs are already aligned accordingly.\\n\")\n    } else {\n      print(x$reversed)\n    }\n    \n    cat(\"\\nConstruct correlations - after alignment\\n\\n\")\n    print(x$cor.after, digits=digits, col.index=col.index, header=FALSE)\n      \n    cat(\"\\nConstruct factor loadings on PC1 - after alignment\\n\\n\")\n    print(x$loadings.after, digits=digits)\n    cat(\"\\n\\n\")\n}\n\n\n#' Align constructs using the ideal element to gain pole preferences.\n#'\n#' The direction of the constructs in a grid is arbitrary and a reflection of \n#' a scale does not affect the information contained in the grid. \n#' Nonetheless, the direction of a scale has an effect on inter-element \n#' correlations (Mackay, 1992) and on the spatial representation and clustering\n#' of the grid (Bell, 2010). Hence, it is desirable to follow a protocol to \n#' align constructs that will render unique results. A common approach is\n#' to align constucts by pole preference, i. e. aligninig all positive and  \n#' negative poles. This can e. g. be achieved using \\code{\\link{swapPoles}}.\n#' If an ideal element is present, this element can be used to identify\n#' the positive and negative pole. The function \\code{alignByIdeal} will\n#' align the constructs accordingly. Note that this approach does not always \n#' yield definite results as sometimes ratings do not show a clear \n#' preference for one pole (Winter, Bell & Watson, 2010).\n#' If a preference cannot be determined definitely,\n#' the construct direction remains unchanged (a warning is issued in that case).\n#' \n#' @param x       \\code{repgrid} object\n#' @param ideal   Number of the element that is used for alignment \n#'                (the ideal).\n#' @param high    Logical. Whether to align the constructs so the ideal \n#'                will have high\n#'                ratings on the constructs (i.e. \\code{TRUE}, default) or low\n#'                ratings (\\code{FALSE}). High scores will lead to the preference pole\n#'                on the right side, low scores will align the preference pole\n#'                on the left side.\n#'\n#' @return        \\code{repgrid} object with aligned constructs.\n#'\n#' @references    Bell, R. C. (2010). A note on aligning constructs.\n#'                \\emph{Personal Construct Theory & Practice, 7}, 42-48.\n#' \n#'                Mackay, N. (1992). Identification, Reflection, \n#'                and Correlation: Problems in ihe bases of repertory \n#'                grid measures. \\emph{International Journal of Personal\n#'                Construct Psychology, 5}(1), 57-75. \n#'          \n#'                Winter, D. A., Bell, R. C., & Watson, S. (2010). Midpoint \n#'                ratings on personal constructs: Constriction or the middle \n#'                way? \\emph{Journal of Constructivist Psychology, 23}(4), 337-356.\n#'\n#' @export\n#' @author    Mark Heckmann\n#' @seealso \\code{\\link{alignByLoadings}}\n#'\n#' @examples \\dontrun{\n#'\n#'   feixas2004                             # original grid\n#'   alignByIdeal(feixas2004, 13)           # aligned with preference pole on the right\n#'\n#'   raeithel                               # original grid\n#'   alignByIdeal(raeithel, 3, high=FALSE)  # aligned with preference pole on the left\n#'\n#' }\n#'\nalignByIdeal <- function(x, ideal, high=TRUE){\n  if (!inherits(x, \"repgrid\")) \t\t\t\t\t\t\t  # check if x is repgrid object\n  \tstop(\"Object x must be of class 'repgrid'\")\n  \t\n  idealRatings <- getRatingLayer(x)[, ideal]\n  unclear <- which(idealRatings == getScaleMidpoint(x))\n  positive <- which(idealRatings > getScaleMidpoint(x))\n  negative <- which(idealRatings < getScaleMidpoint(x))\n  \n  if (high)     \n    x <- swapPoles(x, negative) else   # align such that ratings on ideal are high\n    x <- swapPoles(x, positive)        # align such that ratings on ideal are low\n\n  if (length(unclear) != 0)\n    warning(\"The following constructs do not show a preference for either pole\",\n        \"and have thus not been aligned: \", paste(unclear, collapse=\",\"))\n  x\n}\n\n\n\n#' Cluster analysis (of constructs or elements).\n#'\n#' \\code{cluster} is a preliminary implementation of a cluster function. \n#' It supports\n#' various distance measures as well as cluster methods. More is to come. \n#'\n#' @param x          \\code{repgrid} object.\n#' @param along      Along which dimension to cluster. 1 = constructs only, \n#'                   2= elements only, 0=both (default).\n#' @param dmethod    The distance measure to be used. This must be one of \n#'                   \"euclidean\", \"maximum\", \"manhattan\", \"canberra\", \"binary\" \n#'                   or \"minkowski\". Any unambiguous substring can be given. \n#'                   For additional information on the different types type\n#'                   \\code{?dist}. \n#' @param  cmethod   The agglomeration method to be used. This should be (an\n#'                   unambiguous abbreviation of) one of \\code{\"ward\"}, \n#'                   \\code{\"single\"}, \\code{\"complete\"}, \\code{\"average\"}, \n#'                   \\code{\"mcquitty\"}, \\code{\"median\"} or \\code{\"centroid\"}.\n#' @param  p         The power of the Minkowski distance, in case \\code{\"minkowski\"}\n#'                   is used as argument for \\code{dmethod}.\n#' @param trim       the number of characters a construct is trimmed to (default is\n#'                   \\code{10}). If \\code{NA} no trimming is done. Trimming\n#'                   simply saves space when displaying the output.\n#' @param main       Title of plot. The default is a name indicating the distance \n#'                   function and cluster method.\n#' @param mar        Define the plot region (bottom, left, upper, right).\n#' @param cex        Size parameter for the nodes. Usually not needed.              \n#' @param lab.cex    Size parameter for the constructs on the right side.\n#' @param cex.main   Size parameter for the plot title (default is \\code{.9}).\n#' @param print      Logical. Wether to print the dendrogram (default is \\code{TRUE}).\n#' @param ...        Additional parameters to be passed to plotting function from\n#'                   \\code{as.dendrogram}. Type \\code{?as.dendrogram} for further \n#'                   information. This option is usually not needed, except if special\n#'                   designs are needed.\n#' @return           Reordered \\code{repgrid} object.\n#'\n#' @author            Mark Heckmann\n#' @export\n#' @seealso           \\code{\\link{bertinCluster}}\n#'\n#' @examples \\dontrun{\n#'\n#'   cluster(bell2010)\n#'   cluster(bell2010, main=\"My cluster analysis\")   # new title\n#'   cluster(bell2010, type=\"t\")                     # different drawing style\n#'   cluster(bell2010, dmethod=\"manhattan\")          # using manhattan metric\n#'   cluster(bell2010, cmethod=\"single\")             # do single linkage clustering\n#'   cluster(bell2010, cex=1, lab.cex=1)             # change appearance\n#'   cluster(bell2010, lab.cex=.7,                   # advanced appearance changes\n#'           edgePar = list(lty=1:2, col=2:1))\n#' }\n#'\ncluster <- function(x, along=0, dmethod=\"euclidean\", cmethod=\"ward\", p=2, trim=NA,\n                    main=NULL,\n                    mar=c(4, 2, 3, 15), cex=0, lab.cex=.8, cex.main=.9, \n                    print=TRUE, ...){\n  \n  dmethods <- c(\"euclidean\", \"maximum\", \"manhattan\", \"canberra\", \"binary\", \"minkowski\")\n  dmethod <- match.arg(dmethod, dmethods)\n  \n  cmethods <- c(\"ward\", \"single\", \"complete\", \"average\", \"mcquitty\", \"median\", \"centroid\")\n  cmethod <- match.arg(cmethod, cmethods)\n  \n  if (is.null(main))\n    main <- paste(dmethod, \"distance and\", cmethod, \"clustering\")\n  if (! along %in% 0:2)\n    stop(\"'along must take the value 0, 1 or 2.\")\n    \n  r <- getRatingLayer(x, trim=trim)             # get ratings\n\n  # dendrogram for constructs\n  if (along %in% 0:1){\n    d <- dist(r, method = dmethod, p=p)           # make distance matrix for constructs\n    fit.constructs <- hclust(d, method=cmethod)   # hclust object for constructs\n    dend.con <- as.dendrogram(fit.constructs)\n    con.ord <- order.dendrogram(rev(dend.con))\n    x <- x[con.ord, ]                             # reorder repgrid object    \n  }\n  \n  if (along %in% c(0,2)){\n    # dendrogram for elements\n    d <- dist(t(r), method = dmethod, p=p)        # make distance matrix for elements\n    fit.elements <- hclust(d, method=cmethod)     # hclust object for elements\n    dend.el <- as.dendrogram(fit.elements)\n    el.ord <- order.dendrogram(dend.el)\n    x <- x[ , el.ord]                               # reorder repgrid object\n  }\n   \n  if (print){                                       # print dendrogram?\n    op <- par(mar=mar)                              # change mar settings and save old mar settings\n    if (along == 0)\n      layout(matrix(1:2, ncol=1))  \n    if (along %in% c(0,1)){\n      plot(dend.con, horiz=TRUE, main=main, xlab=\"\",  # print cluster solution\n           nodePar=list(cex=cex, lab.cex=lab.cex), \n           cex.main=cex.main, ...)\n    }\n    if (along %in% c(0,2)){\n      plot(dend.el, horiz=TRUE, main=main, xlab=\"\",  # print cluster solution\n           nodePar=list(cex=cex, lab.cex=lab.cex), \n           cex.main=cex.main, ...)\n    } \n    par(op)                                         # reset to old mar settings  \n  }\n  invisible(x)                                      # return reordered repgrid object\n}\n\n\n\n\n\n\n\n\n\n### using gridn graphics\n# data(mtcars)\n# x  <- t(as.matrix(scale(mtcars)))\n# dd.row <- as.dendrogram(hclust(dist(x)))\n# row.ord <- order.dendrogram(dd.row)\n# \n# dd.col <- as.dendrogram(hclust(dist(t(x))))\n# col.ord <- order.dendrogram(dd.col)\n# library(latticeExtra)\n# dendrogramGrob(dd.col)\n\n\n# data(mtcars)\n# x  <- t(as.matrix(scale(mtcars)))\n# dd.row <- as.dendrogram(hclust(dist(x)))\n# row.ord <- order.dendrogram(dd.row)\n# \n# dd.col <- as.dendrogram(hclust(dist(t(x))))\n# col.ord <- order.dendrogram(dd.col)\n# \n# library(lattice)\n# \n# levelplot(x[row.ord, col.ord],\n#           aspect = \"fill\",\n#           scales = list(x = list(rot = 90)),\n#           colorkey = list(space = \"left\"),\n#           legend =\n#           list(right =\n#                list(fun = dendrogramGrob,\n#                     args =\n#                     list(x = dd.col, ord = col.ord,\n#                          side = \"right\",\n#                          size = 10)),\n#                top =\n#                list(fun = dendrogramGrob,\n#                     args =\n#                     list(x = dd.row, \n#                          side = \"top\",\n#                          type = \"triangle\"))))\n\n\n\n\n\n#' Normalize rows or columns by its standard deviation.  \n#'\n#' @param  x          \\code{matrix}\n#' @param  normalize  A numeric value indicating along what direction (rows, columns)\n#'                    to normalize by standard deviations. \\code{0 = none, 1= rows, 2 = columns}\n#'                    (default is \\code{0}).\n#' @param ...         Not evaluated.\n#' @return            Not yet definde TODO!\n#'\n#' @author        Mark Heckmann\n#' @export\n#'\n#' @examples \\dontrun{\n#'\n#'  x <- matrix(sample(1:5, 20, rep=T), 4)\n#'  normalize(x, 1)\t\t\t\t\t\t      # normalizing rows\n#'  normalize(x, 2)\t\t\t\t\t\t      # normalizing columns\n#' }\n#'\nnormalize <- function(x, normalize=0, ...){\n  if (!normalize %in% 0:2 )\n    stop(\"along must take a numeric value:\\n\",\n         \"normalize, 0 = none, 1 = rows, 2=columns\")\n  if (normalize == 1){\n    x <- t(x) \n    x <- scale(x, center=FALSE, scale=apply(x, 2, sd, na.rm=TRUE))  # see ? scale   \n    x <- t(x)\n  } else  if (normalize == 2){\n    x <- scale(x, center=FALSE, scale=apply(x, 2, sd, na.rm=TRUE))  # see ? scale   \n  }\n  x        \n}\n\n\n#' Centering of rows (constructs) and/or columns (elements).\n#'\n#' @param  x          \\code{repgrid} object.\n#' @param  center\t\t  Numeric. The type of centering to be performed. \n#'                    0= no centering, 1= row mean centering (construct), \n#'                    2= column mean centering (elements), 3= double-centering (construct and element means),\n#'                    4= midpoint centering of rows (constructs).\n#'                    of the scale(default \\code{FALSE}). Default is \\code{1} (row centering).\n#' @param  ...\t\t    Not evaluated.\n#' @return  \\code{matrix} containing the transformed values.\n#'\n#' @note  If scale midpoint centering is applied no row or column centering can be \n#'        applied simultaneously.\n#'        TODO: After centering the standard representation mode does not work any more as \n#'         it remains unclear what color values to attach to the centered values.\n#'\n#' @author        Mark Heckmann\n#' @export\n#'\n#' @examples \\dontrun{\n#'\n#'  center(bell2010)\t\t\t\t\t\t      # no centering\n#'  center(bell2010, rows=T)\t\t\t\t  # row centering of grid \n#'  center(bell2010, cols=T)\t\t\t\t  # column centering of grid\n#'  center(bell2010, rows=T, cols=T)\t# row and column centering\n#' }\n#'\ncenter <- function(x, center=1, ...){\n\tdat <- x@ratings[ , ,1]\n\tif (center == 0)        # no centering\n\t  res <- dat\n\tif (center == 1)        # center at row (construct) mean\n\t  res <- sweep(dat, 1, apply(dat, 1, mean, na.rm=TRUE))\n\tif (center == 2)        # center at column (element) mean\n    res <- sweep(dat, 2, apply(dat, 2, mean, na.rm=TRUE))\n\tif (center == 3){       # center at row and column mean\n    res <- sweep(dat, 1, apply(dat, 1, mean, na.rm=TRUE))\n    res <- sweep(res, 2, apply(res, 2, mean, na.rm=TRUE))\n  }\n  if (center == 4)        # center at midpoint i.e. middle of scale\n\t  res <- dat - getScaleMidpoint(x)  \n\tres\n}\n\n\n#' Calculate SSQ (accuracy) of biplot representation for elements \n#' and constructs. \n#'\n#' Each construct and element are vectors in a \n#' multidimensional space. When reducing the representation \n#' to a lower dimensional space, a loss\n#' of information (sum-of-squares) will usually occur. The output of the function\n#' shows the proportion of sum-of-squares (SSQ) explained for the elements \n#' (constructs) and the amount explained by each principal component. This \n#' allows to assess which elements (construct) are represented how well in the \n#' current representation. Also it shows how much of the total variation is\n#' explained.\n#'\n#' @param x                 \\code{repgrid} object.\n#' @param along             Numeric. Table of sum-of-squares (SSQ) for 1=constructs, \n#'                          2=elements (default). \n#'                          Note that currently these calculations only make sense\n#'                          for biplot reperesentations with \\code{g=1} and \\code{h=1}\n#'                          respectively.\n#' @param  center\t\t        Numeric. The type of centering to be performed. \n#'                          0= no centering, 1= row mean centering (construct), \n#'                          2= column mean centering (elements), 3= double-centering (construct and element means),\n#'                          4= midpoint centering of rows (constructs).\n#'                          The default is \\code{1} (row centering).\n#' @param normalize         A numeric value indicating along what direction (rows, columns)\n#'                          to normalize by standard deviations. \\code{0 = none, 1= rows, 2 = columns}\n#'                          (default is \\code{0}).\n#' @param g                 Power of the singular value matrix assigned to the left singular \n#'                          vectors, i.e. the constructs.\n#' @param h                 Power of the singular value matrix assigned to the right singular \n#'                          vectors, i.e. the elements.\n#' @param col.active        Columns (elements) that are no supplementary points, i.e. they are used\n#'                          in the SVD to find principal components. default is to use all elements.\n#' @param col.passive       Columns (elements) that are supplementary points, i.e. they are NOT used\n#'                          in the SVD but projecte into the component space afterwards. They do not \n#'                          determine the solution. Default is \\code{NA}, i.e. no elements are set \n#'                          supplementary.\n#' @return                  A list containing three wo elements \\cr\n#'                          \\item{ssq.table}{dataframe with sum-of-squares explained for \n#'                                           element/construct by each dimension}\n#'                          \\item{ssq.table.cumsum}{dataframe with cumulated \n#'                                                  sum-of-squares explained for \n#'                                                  element/construct number of dimensions}                          \n#'                          \\item{ssq.total}{total sum-of-squares after pre-transforming grid matrix}\n#'                          \n#' @note                    TODO: if g or h is not equal to 1 the SSQ does not measure\n#'                          accuracy of representation as currently the ssq of each point\n#'                          are set in constrast with the pre-transformed matrix.\n#'\n#' @author        Mark Heckmann\n#' @keywords      internal\n#' @export\n#' @examples\n#' \n#'  # explained sum-of-squares for elements\n#'  ssq(bell2010)\n#'  \n#'  # explained sum-of-squares for constructs\n#'  ssq(bell2010, along=1)\n#'  \n#'  # save results\n#'  s <- ssq(bell2010)\n#'  \n#'  # printing options\n#'  print(s)\n#'  print(s, digits=4)\n#'  print(s, dim=3)\n#'  print(s, cumulated=FALSE)\n#'  \n#'  # access results\n#'  names(s)\n#'  s$ssq.table\n#'  s$ssq.table.cumsum\n#'  s$ssq.total\n#'  \nssq <- function(x, along=2, center=1, normalize=0, \n                g=0, h=1-g, col.active=NA, col.passive=NA, ...){ \n  x <- calcBiplotCoords(x, center=center, normalize=normalize, \n                        g=g, h=h,  col.active= col.active, \n                        col.passive=col.passive)\n  if (is.null(x@calcs$biplot))\n    stop(\"biplot coordinates have not yet been calculated\")\n  \n  E <- x@calcs$biplot$el\n  C <- x@calcs$biplot$con\n  X <- x@calcs$biplot$X\n  \n  enames <- getElementNames(x)\n  cnames <- getConstructNames(x)$rightpole\n  \n  ssq.c <- diag(X %*% t(X))         # SSQ for each row (constructs)\n  ssq.e <- diag(t(X) %*% X)         # SSQ for each column(element)\n  ssq.c.prop <- C^2 / ssq.c         # ssq of row and dimension / total ssq element  \n  ssq.e.prop <- E^2 / ssq.e         # ssq of element and dimension / total ssq element  \n \n  rownames(ssq.c.prop) <- cnames    # add construct names to rows\n  colnames(ssq.c.prop) <-           # add dimension labels to columns\n    paste(1L:ncol(ssq.c.prop), \"D\", sep=\"\") \n  rownames(ssq.e.prop) <- enames    # add element names to rows\n  colnames(ssq.e.prop) <-           # add dimension labels to columns\n    paste(1L:ncol(ssq.e.prop), \"D\", sep=\"\")\n\n  ssq.c.cumsum <- t(apply(ssq.c.prop, 1, cumsum))         # cumulated ssq of construct per dimension / total ssq element \n  ssq.e.cumsum <- t(apply(ssq.e.prop, 1, cumsum))         # cumulated ssq of elements per dimension / total ssq element \n  ssq.c.avg <- apply(C^2, 2, sum, na.rm=T) / sum(ssq.c)   # ssq per dimension / ssq total \n  ssq.e.avg <- apply(E^2, 2, sum, na.rm=T) / sum(ssq.e)   # ssq per dimension / ssq total\n  ssq.c.avg.cumsum <- cumsum(ssq.c.avg)                     # cumulated ssq per dimension / ssq total\n  ssq.e.avg.cumsum <- cumsum(ssq.e.avg)                     # cumulated ssq per dimension / ssq total\n  ssq.c.table <- rbind(ssq.c.prop, TOTAL=ssq.c.avg)         # \n  ssq.e.table <- rbind(ssq.e.prop, TOTAL=ssq.e.avg)         # \n  ssq.c.table.cumsum <- rbind(ssq.c.cumsum, TOTAL=ssq.c.avg.cumsum)\n  ssq.e.table.cumsum <- rbind(ssq.e.cumsum, TOTAL=ssq.e.avg.cumsum)\n  ssq.c.table <- ssq.c.table * 100\n  ssq.e.table <- ssq.e.table * 100\n  ssq.c.table.cumsum <- ssq.c.table.cumsum * 100\n  ssq.e.table.cumsum <- ssq.e.table.cumsum * 100\n  \n  if (along == 1){          # elements or constructs?\n    ssq.table <- ssq.c.table\n    ssq.table.cumsum <- ssq.c.table.cumsum\n    along.text <- \"constructs\"\n  } else {\n    ssq.table <- ssq.e.table\n    ssq.table.cumsum <- ssq.e.table.cumsum\n    along.text <- \"elements\"\n  }\n  \n  l <- list(ssq.table=ssq.table, \n            ssq.table.cumsum=ssq.table.cumsum, \n            ssq.total=sum(ssq.e))\n  attr(l, \"arguments\") <- list(along.text=along.text)\n  class(l) <- \"ssq\"\n  return(l) \n}\n\n\n#' Print method for class ssq.\n#' \n#' @param x                 Object of class ssq.\n#' @param digits            Number of digits to round the output to (default is \\code{2}).\n#' @param dim               The number of PCA dimensions to print. Default\n#'                          is \\code{5} dimensions. \\code{NA} will print all \n#'                          dimensions.\n#' @param cumulated         Logical (default is \\code{TRUE}). \n#'                          Print a cumulated table of sum-of-squares?\n#'                          If \\code{FALSE} the uncumulated sum-of-squares are printed.                         \n#'                          (default is \\code{TRUE}).\n#' @param ...               Not evaluated.\n#' @export\n#' @method            print ssq\n#' @keywords          internal\n#'\n#'\nprint.ssq <- function(x, digits=2, dim=5, cumulated=TRUE, ...)\n{\n  # dimensions to print\n  if (is.na(dim[1]))\n    dim <- ncol(x$ssq.table)\n  args <- attr(x, \"arguments\")\n  if (cumulated) {                 # output cumulated table?\n    ssq.out <- x$ssq.table.cumsum \n    cum.text <- \"Cumulated proportion\"\n  } else {\n    ssq.out <- x$ssq.table    \n    cum.text <- \"Proportion\"\n  }\n  cat(\"\\n\", cum.text, \"of explained sum-of-squares for \", \n      args$along.text, \"\\n\\n\", sep=\"\")\n  print(round(ssq.out[, 1:dim], digits))\n  cat(\"\\nTotal sum-of-squares of pre-transformed \", \n      \"(i.e. centered and scaled) matrix:\", x$ssq.total) \n}\n\n\n",
    "created" : 1352668559554.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "867507191",
    "id" : "76E1729C",
    "lastKnownWriteTime" : 1352819694,
    "path" : "~/Documents/R/pkg_dev/grid/OpenRepGrid/OpenRepGrid/R/calc.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}